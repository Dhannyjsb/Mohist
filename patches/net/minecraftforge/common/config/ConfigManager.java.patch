--- ../src-base/minecraft/net/minecraftforge/common/config/ConfigManager.java
+++ ../src-work/minecraft/net/minecraftforge/common/config/ConfigManager.java
@@ -19,20 +19,12 @@
 
 package net.minecraftforge.common.config;
 
-import java.io.File;
-import java.lang.reflect.Field;
-import java.lang.reflect.Modifier;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-
 import com.google.common.base.Joiner;
 import com.google.common.base.Strings;
 import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Sets;
-
 import net.minecraftforge.common.config.Config.Comment;
 import net.minecraftforge.common.config.Config.LangKey;
 import net.minecraftforge.common.config.Config.Name;
@@ -43,74 +35,78 @@
 import net.minecraftforge.fml.common.discovery.ASMDataTable;
 import net.minecraftforge.fml.common.discovery.ASMDataTable.ASMData;
 import net.minecraftforge.fml.common.discovery.asm.ModAnnotation.EnumHolder;
-
 import org.apache.commons.lang3.StringUtils;
 
-public class ConfigManager
-{
-    private static Map<String, Multimap<Config.Type, ASMData>> asm_data = Maps.newHashMap();
+import java.io.File;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+
+public class ConfigManager {
+    static final Joiner NEW_LINE = Joiner.on('\n');
+    static final Joiner PIPE = Joiner.on('|');
     static Map<Class<?>, ITypeAdapter> ADAPTERS = Maps.newHashMap();
     static Map<Class<?>, Class<?>> ARRAY_REMAP = Maps.newHashMap();
+    private static Map<String, Multimap<Config.Type, ASMData>> asm_data = Maps.newHashMap();
     private static Map<String, Configuration> CONFIGS = Maps.newHashMap();
     private static Map<String, Set<Class<?>>> MOD_CONFIG_CLASSES = Maps.newHashMap();
 
-    static
-    {
-        register(boolean.class,     TypeAdapters.bool);
-        register(boolean[].class,   TypeAdapters.boolA);
-        register(Boolean.class,     TypeAdapters.Bool);
-        register(Boolean[].class,   TypeAdapters.BoolA);
-        register(float.class,       TypeAdapters.flt);
-        register(float[].class,     TypeAdapters.fltA);
-        register(Float.class,       TypeAdapters.Flt);
-        register(Float[].class,     TypeAdapters.FltA);
-        register(double.class,      TypeAdapters.dbl);
-        register(double[].class,    TypeAdapters.dblA);
-        register(Double.class,      TypeAdapters.Dbl);
-        register(Double[].class,    TypeAdapters.DblA);
-        register(byte.class,        TypeAdapters.byt);
-        register(byte[].class,      TypeAdapters.bytA);
-        register(Byte.class,        TypeAdapters.Byt);
-        register(Byte[].class,      TypeAdapters.BytA);
-        register(char.class,        TypeAdapters.chr);
-        register(char[].class,      TypeAdapters.chrA);
-        register(Character.class,   TypeAdapters.Chr);
+    static {
+        register(boolean.class, TypeAdapters.bool);
+        register(boolean[].class, TypeAdapters.boolA);
+        register(Boolean.class, TypeAdapters.Bool);
+        register(Boolean[].class, TypeAdapters.BoolA);
+        register(float.class, TypeAdapters.flt);
+        register(float[].class, TypeAdapters.fltA);
+        register(Float.class, TypeAdapters.Flt);
+        register(Float[].class, TypeAdapters.FltA);
+        register(double.class, TypeAdapters.dbl);
+        register(double[].class, TypeAdapters.dblA);
+        register(Double.class, TypeAdapters.Dbl);
+        register(Double[].class, TypeAdapters.DblA);
+        register(byte.class, TypeAdapters.byt);
+        register(byte[].class, TypeAdapters.bytA);
+        register(Byte.class, TypeAdapters.Byt);
+        register(Byte[].class, TypeAdapters.BytA);
+        register(char.class, TypeAdapters.chr);
+        register(char[].class, TypeAdapters.chrA);
+        register(Character.class, TypeAdapters.Chr);
         register(Character[].class, TypeAdapters.ChrA);
-        register(short.class,       TypeAdapters.shrt);
-        register(short[].class,     TypeAdapters.shrtA);
-        register(Short.class,       TypeAdapters.Shrt);
-        register(Short[].class,     TypeAdapters.ShrtA);
-        register(int.class,         TypeAdapters.int_);
-        register(int[].class,       TypeAdapters.intA);
-        register(Integer.class,     TypeAdapters.Int);
-        register(Integer[].class,   TypeAdapters.IntA);
-        register(String.class,      TypeAdapters.Str);
-        register(String[].class,    TypeAdapters.StrA);
+        register(short.class, TypeAdapters.shrt);
+        register(short[].class, TypeAdapters.shrtA);
+        register(Short.class, TypeAdapters.Shrt);
+        register(Short[].class, TypeAdapters.ShrtA);
+        register(int.class, TypeAdapters.int_);
+        register(int[].class, TypeAdapters.intA);
+        register(Integer.class, TypeAdapters.Int);
+        register(Integer[].class, TypeAdapters.IntA);
+        register(String.class, TypeAdapters.Str);
+        register(String[].class, TypeAdapters.StrA);
 
 
-        ARRAY_REMAP.put(Boolean.class,   Boolean[].class  );
-        ARRAY_REMAP.put(Float.class,     Float[].class    );
-        ARRAY_REMAP.put(Double.class,    Double[].class   );
-        ARRAY_REMAP.put(Byte.class,      Byte[].class     );
+        ARRAY_REMAP.put(Boolean.class, Boolean[].class);
+        ARRAY_REMAP.put(Float.class, Float[].class);
+        ARRAY_REMAP.put(Double.class, Double[].class);
+        ARRAY_REMAP.put(Byte.class, Byte[].class);
         ARRAY_REMAP.put(Character.class, Character[].class);
-        ARRAY_REMAP.put(Short.class,     Short[].class    );
-        ARRAY_REMAP.put(Integer.class,   Integer[].class  );
-        ARRAY_REMAP.put(String.class,    String[].class   );
+        ARRAY_REMAP.put(Short.class, Short[].class);
+        ARRAY_REMAP.put(Integer.class, Integer[].class);
+        ARRAY_REMAP.put(String.class, String[].class);
     }
-    private static void register(Class<?> cls, ITypeAdapter adpt)
-    {
+
+    private static void register(Class<?> cls, ITypeAdapter adpt) {
         ADAPTERS.put(cls, adpt);
     }
 
-    public static void loadData(ASMDataTable data)
-    {
+    public static void loadData(ASMDataTable data) {
         FMLLog.log.debug("Loading @Config anotation data");
-        for (ASMData target : data.getAll(Config.class.getName()))
-        {
-            String modid = (String)target.getAnnotationInfo().get("modid");
+        for (ASMData target : data.getAll(Config.class.getName())) {
+            String modid = (String) target.getAnnotationInfo().get("modid");
             Multimap<Config.Type, ASMData> map = asm_data.computeIfAbsent(modid, k -> ArrayListMultimap.create());
 
-            EnumHolder tholder = (EnumHolder)target.getAnnotationInfo().get("type");
+            EnumHolder tholder = (EnumHolder) target.getAnnotationInfo().get("type");
             Config.Type type = tholder == null ? Config.Type.INSTANCE : Config.Type.valueOf(tholder.getValue());
 
             map.put(type, target);
@@ -121,8 +117,7 @@
      * Bounces to sync().
      * TODO: remove
      */
-    public static void load(String modid, Config.Type type)
-    {
+    public static void load(String modid, Config.Type type) {
         sync(modid, type);
     }
 
@@ -143,8 +138,7 @@
      * @param modid the mod's ID for which the configuration shall be loaded
      * @param type the configuration type, currently always {@code Config.Type.INSTANCE}
      */
-    public static void sync(String modid, Config.Type type)
-    {
+    public static void sync(String modid, Config.Type type) {
         FMLLog.log.debug("Attempting to inject @Config classes into {} for type {}", modid, type);
         ClassLoader mcl = Loader.instance().getModClassLoader();
         File configDir = Loader.instance().getConfigDir();
@@ -153,27 +147,24 @@
         if (map == null)
             return;
 
-        for (ASMData targ : map.get(type))
-        {
-            try
-            {
+        for (ASMData targ : map.get(type)) {
+            try {
                 Class<?> cls = Class.forName(targ.getClassName(), true, mcl);
 
                 Set<Class<?>> modConfigClasses = MOD_CONFIG_CLASSES.computeIfAbsent(modid, k -> Sets.<Class<?>>newHashSet());
                 modConfigClasses.add(cls);
 
-                String name = (String)targ.getAnnotationInfo().get("name");
+                String name = (String) targ.getAnnotationInfo().get("name");
                 if (name == null)
                     name = modid;
-                String category = (String)targ.getAnnotationInfo().get("category");
+                String category = (String) targ.getAnnotationInfo().get("category");
                 if (category == null)
                     category = "general";
 
                 File file = new File(configDir, name + ".cfg");
 
                 Configuration cfg = CONFIGS.get(file.getAbsolutePath());
-                if (cfg == null)
-                {
+                if (cfg == null) {
                     cfg = new Configuration(file);
                     cfg.load();
                     CONFIGS.put(file.getAbsolutePath(), cfg);
@@ -183,22 +174,18 @@
 
                 cfg.save();
 
-            }
-            catch (Exception e)
-            {
+            } catch (Exception e) {
                 FMLLog.log.error("An error occurred trying to load a config for {} into {}", modid, targ.getClassName(), e);
                 throw new LoaderException(e);
             }
         }
     }
 
-    public static Class<?>[] getModConfigClasses(String modid)
-    {
+    public static Class<?>[] getModConfigClasses(String modid) {
         return (MOD_CONFIG_CLASSES.containsKey(modid) ? MOD_CONFIG_CLASSES.get(modid).toArray(new Class<?>[0]) : new Class<?>[0]);
     }
 
-    public static boolean hasConfigForMod(String modid)
-    {
+    public static boolean hasConfigForMod(String modid) {
         return asm_data.containsKey(modid);
     }
 
@@ -213,10 +200,8 @@
         return CONFIGS.get(configFile.getAbsolutePath());
     }
 
-    private static void sync(Configuration cfg, Class<?> cls, String modid, String category, boolean loading, Object instance)
-    {
-        for (Field f : cls.getDeclaredFields())
-        {
+    private static void sync(Configuration cfg, Class<?> cls, String modid, String category, boolean loading, Object instance) {
+        for (Field f : cls.getDeclaredFields()) {
             if (!Modifier.isPublic(f.getModifiers()))
                 continue;
 
@@ -246,8 +231,7 @@
             {
                 if (Strings.isNullOrEmpty(category))
                     throw new RuntimeException("An empty category may not contain anything but objects representing categories!");
-                try
-                {
+                try {
                     IFieldWrapper wrapper = FieldWrapper.get(instance, f, category);
                     ITypeAdapter adapt = wrapper.getTypeAdapter();
                     Property.Type propType = adapt.getType();
@@ -265,8 +249,7 @@
                                 adapt.setValue(property, wrapper.getValue(key));
                             else
                                 wrapper.setValue(key, adapt.getValue(property));
-                        }
-                        else //If the key is not new, sync according to shouldReadFromVar()
+                        } else //If the key is not new, sync according to shouldReadFromVar()
                         {
                             Property property = property(cfg, wrapper.getCategory(), suffix, propType, adapt.isArrayAdapter());
                             Object propVal = adapt.getValue(property);
@@ -287,8 +270,7 @@
                         if (!wrapper.handlesKey(key))
                             continue;
 
-                        if (loading || !wrapper.hasKey(key))
-                        {
+                        if (loading || !wrapper.hasKey(key)) {
                             Object value = wrapper.getTypeAdapter().getValue(property);
                             wrapper.setValue(key, value);
                         }
@@ -297,23 +279,16 @@
                     if (loading)
                         wrapper.setupConfiguration(cfg, comment, langKey, requiresMcRestart, requiresWorldRestart, hasSlidingControl);
 
-                }
-                catch (Exception e)
-                {
+                } catch (Exception e) {
                     String format = "Error syncing field '%s' of class '%s'!";
                     String error = String.format(format, f.getName(), cls.getName());
                     throw new RuntimeException(error, e);
                 }
-            }
-            else if (f.getType().getSuperclass() != null && f.getType().getSuperclass().equals(Object.class))
-            { //If the field extends Object directly, descend the object tree and access the objects members
+            } else if (f.getType().getSuperclass() != null && f.getType().getSuperclass().equals(Object.class)) { //If the field extends Object directly, descend the object tree and access the objects members
                 Object newInstance = null;
-                try
-                {
+                try {
                     newInstance = f.get(instance);
-                }
-                catch (IllegalAccessException e)
-                {
+                } catch (IllegalAccessException e) {
                     throw new RuntimeException(e);
                 }
 
@@ -326,9 +301,7 @@
                 confCat.setRequiresWorldRestart(requiresWorldRestart);
 
                 sync(cfg, f.getType(), modid, sub, loading, newInstance);
-            }
-            else
-            {
+            } else {
                 String format = "Can't handle field '%s' of class '%s': Unknown type.";
                 String error = String.format(format, f.getName(), cls.getCanonicalName());
                 throw new RuntimeException(error);
@@ -336,32 +309,24 @@
         }
     }
 
-    static final Joiner NEW_LINE = Joiner.on('\n');
-    static final Joiner PIPE = Joiner.on('|');
-
-    private static Property property(Configuration cfg, String category, String property, Property.Type type, boolean isList)
-    {
+    private static Property property(Configuration cfg, String category, String property, Property.Type type, boolean isList) {
         Property prop = cfg.getCategory(category).get(property);
-        if (prop == null)
-        {
+        if (prop == null) {
             if (isList)
                 prop = new Property(property, new String[0], type);
             else
-                prop = new Property(property, (String)null, type);
+                prop = new Property(property, (String) null, type);
             cfg.getCategory(category).put(property, prop);
         }
         return prop;
     }
 
-    private static boolean exists(Configuration cfg, String category, String property)
-    {
+    private static boolean exists(Configuration cfg, String category, String property) {
         return cfg.hasCategory(category) && cfg.getCategory(category).containsKey(property);
     }
 
-    private static boolean shouldReadFromVar(Property property, Object propValue, Object fieldValue)
-    {
-        if (!propValue.equals(fieldValue))
-        {
+    private static boolean shouldReadFromVar(Property property, Object propValue, Object fieldValue) {
+        if (!propValue.equals(fieldValue)) {
             if (property.hasChanged())
                 return false;
             else
@@ -370,8 +335,7 @@
         return false;
     }
 
-    private static String getName(Field f)
-    {
+    private static String getName(Field f) {
         if (f.isAnnotationPresent(Name.class))
             return f.getAnnotation(Name.class).value();
         return f.getName();

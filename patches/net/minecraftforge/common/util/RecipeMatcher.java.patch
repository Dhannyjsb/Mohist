--- ../src-base/minecraft/net/minecraftforge/common/util/RecipeMatcher.java
+++ ../src-work/minecraft/net/minecraftforge/common/util/RecipeMatcher.java
@@ -19,15 +19,14 @@
 
 package net.minecraftforge.common.util;
 
+import com.google.common.base.Predicate;
+
 import java.util.BitSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 
-import com.google.common.base.Predicate;
-
-public class RecipeMatcher
-{
+public class RecipeMatcher {
     /**
      * Attempts to match inputs to the specified tests. In the best way that all inputs are used by one test.
      * Will return null in any of these cases:
@@ -38,8 +37,7 @@
      *
      * @return An array mapping inputs to tests. ret[x] = y means input[x] = test[y]
      */
-    public static <T> int[] findMatches(List<T> inputs, List<? extends Predicate<T>> tests)
-    {
+    public static <T> int[] findMatches(List<T> inputs, List<? extends Predicate<T>> tests) {
         int elements = inputs.size();
         if (elements != tests.size())
             return null; // There will not be a 1:1 mapping of inputs -> tests
@@ -50,19 +48,16 @@
 
         // [UnusedInputs] [UnusedIngredients] [IngredientMatchMask]...
         BitSet data = new BitSet((elements + 2) * elements);
-        for (int x = 0; x < elements; x++)
-        {
+        for (int x = 0; x < elements; x++) {
             int matched = 0;
             int offset = (x + 2) * elements;
             Predicate<T> test = tests.get(x);
 
-            for (int y = 0; y < elements; y++)
-            {
+            for (int y = 0; y < elements; y++) {
                 if (data.get(y))
                     continue;
 
-                if (test.apply(inputs.get(y)))
-                {
+                if (test.apply(inputs.get(y))) {
                     data.set(offset + y);
                     matched++;
                 }
@@ -71,8 +66,7 @@
             if (matched == 0)
                 return null; //We have an test that matched non of the inputs
 
-            if (matched == 1)
-            {
+            if (matched == 1) {
                 if (!claim(ret, data, x, elements))
                     return null; //We failed to claim this index, which means it caused something else to go to 0 matches, which makes the whole thing fail
             }
@@ -90,29 +84,25 @@
     }
 
     // This is bad... need to think of a better cascade, recursion instead of stack?
-    private static boolean claim(int[] ret, BitSet data, int claimed, int elements)
-    {
+    private static boolean claim(int[] ret, BitSet data, int claimed, int elements) {
         Queue<Integer> pending = new LinkedList<Integer>();
         pending.add(claimed);
 
-        while (pending.peek() != null)
-        {
+        while (pending.peek() != null) {
             int test = pending.poll();
             int offset = (test + 2) * elements;
             int used = data.nextSetBit(offset) - offset;
 
             if (used >= elements || used < 0)
-                throw new IllegalStateException("What? We matched something, but it wasn't set in the range of this test! Test: " + test +  " Used: " + used);
+                throw new IllegalStateException("What? We matched something, but it wasn't set in the range of this test! Test: " + test + " Used: " + used);
 
             data.set(used);
             data.set(elements + test);
             ret[used] = test;
 
-            for (int x = 0; x < elements; x++)
-            {
+            for (int x = 0; x < elements; x++) {
                 offset = (x + 2) * elements;
-                if (data.get(offset + used) && !data.get(elements + x))
-                {
+                if (data.get(offset + used) && !data.get(elements + x)) {
                     data.clear(offset + used);
                     int count = 0;
                     for (int y = offset; y < offset + elements; y++)
@@ -132,32 +122,29 @@
     }
 
     //We use recursion here, why? Because I feel like it. Also because we should only ever be working in data sets < 9
-    private static boolean backtrack(BitSet data, int[] ret, int start, int elements)
-    {
-      int test = data.nextClearBit(elements + start) - elements;
-      if (test >= elements)
-        return true; //Could not find the next unused test.
+    private static boolean backtrack(BitSet data, int[] ret, int start, int elements) {
+        int test = data.nextClearBit(elements + start) - elements;
+        if (test >= elements)
+            return true; //Could not find the next unused test.
 
-      if (test < 0)
-        throw new IllegalStateException("This should never happen, negative test in backtrack!");
+        if (test < 0)
+            throw new IllegalStateException("This should never happen, negative test in backtrack!");
 
-      int offset = (test + 2) * elements;
-      for (int x = 0; x < elements; x++)
-      {
-        if (!data.get(offset + x) || data.get(x))
-            continue;
+        int offset = (test + 2) * elements;
+        for (int x = 0; x < elements; x++) {
+            if (!data.get(offset + x) || data.get(x))
+                continue;
 
-        data.set(x);
+            data.set(x);
 
-        if (backtrack(data, ret, test + 1, elements))
-        {
-            ret[x] = test;
-            return true;
+            if (backtrack(data, ret, test + 1, elements)) {
+                ret[x] = test;
+                return true;
+            }
+
+            data.clear(x);
         }
 
-        data.clear(x);
-      }
-
-      return false;
+        return false;
     }
 }

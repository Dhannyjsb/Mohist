--- ../src-base/minecraft/net/minecraftforge/common/model/TRSRTransformation.java
+++ ../src-work/minecraft/net/minecraftforge/common/model/TRSRTransformation.java
@@ -19,22 +19,8 @@
 
 package net.minecraftforge.common.model;
 
-import java.util.EnumMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-
-import javax.annotation.Nullable;
-import javax.vecmath.AxisAngle4f;
-import javax.vecmath.Matrix3f;
-import javax.vecmath.Matrix4f;
-import javax.vecmath.Quat4f;
-import javax.vecmath.SingularMatrixException;
-import javax.vecmath.Tuple3f;
-import javax.vecmath.Tuple4f;
-import javax.vecmath.Vector3f;
-import javax.vecmath.Vector4f;
-
+import com.google.common.base.MoreObjects;
+import com.google.common.collect.Maps;
 import net.minecraft.client.renderer.block.model.ItemTransformVec3f;
 import net.minecraft.client.renderer.block.model.ModelRotation;
 import net.minecraft.util.EnumFacing;
@@ -42,12 +28,15 @@
 import net.minecraftforge.client.ForgeHooksClient;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
-
 import org.apache.commons.lang3.tuple.Pair;
 import org.apache.commons.lang3.tuple.Triple;
 
-import com.google.common.base.MoreObjects;
-import com.google.common.collect.Maps;
+import javax.annotation.Nullable;
+import javax.vecmath.*;
+import java.util.EnumMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
 
 /*
  * Interpolation-friendly affine transformation.
@@ -61,282 +50,249 @@
  * should be comparable to using Matrix4f directly.
  * Immutable.
  */
-public final class TRSRTransformation implements IModelState, ITransformation
-{
-    private final Matrix4f matrix;
+public final class TRSRTransformation implements IModelState, ITransformation {
+    private static final TRSRTransformation identity;
+    private static final float eps = 1e-6f;
+    private static final float g = 3f + 2f * (float) Math.sqrt(2);
+    private static final float cs = (float) Math.cos(Math.PI / 8);
+    private static final float ss = (float) Math.sin(Math.PI / 8);
+    private static final float sq2 = 1f / (float) Math.sqrt(2);
+    private static final EnumMap<EnumFacing, TRSRTransformation> vanillaUvTransformLocalToGlobal = Maps.newEnumMap(EnumFacing.class);
+    private static final EnumMap<EnumFacing, TRSRTransformation> vanillaUvTransformGlobalToLocal = Maps.newEnumMap(EnumFacing.class);
 
+    static {
+        Matrix4f m = new Matrix4f();
+        m.setIdentity();
+        identity = new TRSRTransformation(m);
+        identity.getLeftRot();
+    }
+
+    static {
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.SOUTH, identity);
+        Quat4f tmp = new Quat4f();
+        tmp.set(new AxisAngle4f(0, 1, 0, (float) Math.toRadians(90)));
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.EAST, new TRSRTransformation(null, new Quat4f(tmp), null, null));
+        tmp.set(new AxisAngle4f(0, 1, 0, (float) Math.toRadians(-90)));
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.WEST, new TRSRTransformation(null, new Quat4f(tmp), null, null));
+        tmp.set(new AxisAngle4f(0, 1, 0, (float) Math.toRadians(180)));
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.NORTH, new TRSRTransformation(null, new Quat4f(tmp), null, null));
+        tmp.set(new AxisAngle4f(1, 0, 0, (float) Math.toRadians(-90)));
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.UP, new TRSRTransformation(null, new Quat4f(tmp), null, null));
+        tmp.set(new AxisAngle4f(1, 0, 0, (float) Math.toRadians(90)));
+        vanillaUvTransformLocalToGlobal.put(EnumFacing.DOWN, new TRSRTransformation(null, new Quat4f(tmp), null, null));
+
+        for (EnumFacing side : EnumFacing.values()) {
+            vanillaUvTransformGlobalToLocal.put(side, vanillaUvTransformLocalToGlobal.get(side).inverse());
+        }
+    }
+
+    private final Matrix4f matrix;
     private boolean full;
     private Vector3f translation;
     private Quat4f leftRot;
     private Vector3f scale;
     private Quat4f rightRot;
-
     private Matrix3f normalTransform;
 
-    public TRSRTransformation(@Nullable Matrix4f matrix)
-    {
-        if(matrix == null)
-        {
+    public TRSRTransformation(@Nullable Matrix4f matrix) {
+        if (matrix == null) {
             this.matrix = identity.matrix;
-        }
-        else
-        {
+        } else {
             this.matrix = matrix;
         }
     }
 
-    public TRSRTransformation(@Nullable Vector3f translation, @Nullable Quat4f leftRot, @Nullable Vector3f scale, @Nullable Quat4f rightRot)
-    {
+    public TRSRTransformation(@Nullable Vector3f translation, @Nullable Quat4f leftRot, @Nullable Vector3f scale, @Nullable Quat4f rightRot) {
         this.matrix = mul(translation, leftRot, scale, rightRot);
         this.translation = translation != null ? translation : new Vector3f();
         this.leftRot = leftRot != null ? leftRot : new Quat4f(0, 0, 0, 1);
         this.scale = scale != null ? scale : new Vector3f(1, 1, 1);
-        this.rightRot = rightRot!= null ? rightRot : new Quat4f(0, 0, 0, 1);
+        this.rightRot = rightRot != null ? rightRot : new Quat4f(0, 0, 0, 1);
         full = true;
     }
 
     /** @deprecated use {@link #from(ItemTransformVec3f)} */
     @Deprecated // TODO: remove / make private
     @SideOnly(Side.CLIENT)
-    public TRSRTransformation(ItemTransformVec3f transform)
-    {
+    public TRSRTransformation(ItemTransformVec3f transform) {
         this(toVecmath(transform.translation), quatFromXYZDegrees(toVecmath(transform.rotation)), toVecmath(transform.scale), null);
     }
 
     /** @deprecated use {@link #from(ModelRotation)} */
     @Deprecated // TODO: remove
     @SideOnly(Side.CLIENT)
-    public TRSRTransformation(ModelRotation rotation)
-    {
+    public TRSRTransformation(ModelRotation rotation) {
         this(rotation.getMatrix());
     }
 
     /** @deprecated use {@link #from(EnumFacing)} */
     @Deprecated // TODO: remove
     @SideOnly(Side.CLIENT)
-    public TRSRTransformation(EnumFacing facing)
-    {
+    public TRSRTransformation(EnumFacing facing) {
         this(getMatrix(facing));
     }
 
     @Deprecated
     @SideOnly(Side.CLIENT)
-    public static TRSRTransformation from(ItemTransformVec3f transform)
-    {
+    public static TRSRTransformation from(ItemTransformVec3f transform) {
         return transform.equals(ItemTransformVec3f.DEFAULT) ? identity : new TRSRTransformation(transform);
     }
 
     @SideOnly(Side.CLIENT)
-    public static TRSRTransformation from(ModelRotation rotation)
-    {
+    public static TRSRTransformation from(ModelRotation rotation) {
         return Cache.get(rotation);
     }
 
     @SideOnly(Side.CLIENT)
-    public static TRSRTransformation from(EnumFacing facing)
-    {
+    public static TRSRTransformation from(EnumFacing facing) {
         return Cache.get(getRotation(facing));
     }
 
     @SideOnly(Side.CLIENT)
-    public static Matrix4f getMatrix(EnumFacing facing)
-    {
+    public static Matrix4f getMatrix(EnumFacing facing) {
         return getRotation(facing).getMatrix();
     }
 
     @SideOnly(Side.CLIENT)
-    public static ModelRotation getRotation(EnumFacing facing)
-    {
-        switch (facing)
-        {
-        case DOWN:  return ModelRotation.X90_Y0;
-        case UP:    return ModelRotation.X270_Y0;
-        case NORTH: return ModelRotation.X0_Y0;
-        case SOUTH: return ModelRotation.X0_Y180;
-        case WEST:  return ModelRotation.X0_Y270;
-        case EAST:  return ModelRotation.X0_Y90;
+    public static ModelRotation getRotation(EnumFacing facing) {
+        switch (facing) {
+            case DOWN:
+                return ModelRotation.X90_Y0;
+            case UP:
+                return ModelRotation.X270_Y0;
+            case NORTH:
+                return ModelRotation.X0_Y0;
+            case SOUTH:
+                return ModelRotation.X0_Y180;
+            case WEST:
+                return ModelRotation.X0_Y270;
+            case EAST:
+                return ModelRotation.X0_Y90;
         }
         throw new IllegalArgumentException(String.valueOf(facing));
     }
 
-    private static final TRSRTransformation identity;
-
-    static
-    {
-        Matrix4f m = new Matrix4f();
-        m.setIdentity();
-        identity = new TRSRTransformation(m);
-        identity.getLeftRot();
-    }
-
-    public static TRSRTransformation identity()
-    {
+    public static TRSRTransformation identity() {
         return identity;
     }
 
-    public TRSRTransformation compose(TRSRTransformation b)
-    {
-        if (this.isIdentity()) return b;
-        if (b.isIdentity()) return this;
-        Matrix4f m = getMatrix();
-        m.mul(b.getMatrix());
-        return new TRSRTransformation(m);
-    }
-
-    public TRSRTransformation inverse()
-    {
-        if (this.isIdentity()) return this;
-        Matrix4f m = getMatrix();
-        m.invert();
-        return new TRSRTransformation(m);
-    }
-
-    private void genCheck()
-    {
-        if(!full)
-        {
-            Pair<Matrix3f, Vector3f> pair = toAffine(matrix);
-            Triple<Quat4f, Vector3f, Quat4f> triple = svdDecompose(pair.getLeft());
-            this.translation = pair.getRight();
-            this.leftRot = triple.getLeft();
-            this.scale = triple.getMiddle();
-            this.rightRot = triple.getRight();
-            full = true;
-        }
-    }
-
-    public static Quat4f quatFromYXZ(float y, float x, float z)
-    {
+    public static Quat4f quatFromYXZ(float y, float x, float z) {
         Quat4f ret = new Quat4f(0, 0, 0, 1), t = new Quat4f();
-        t.set(0, (float)Math.sin(y/2), 0, (float)Math.cos(y/2));
+        t.set(0, (float) Math.sin(y / 2), 0, (float) Math.cos(y / 2));
         ret.mul(t);
-        t.set((float)Math.sin(x/2), 0, 0, (float)Math.cos(x/2));
+        t.set((float) Math.sin(x / 2), 0, 0, (float) Math.cos(x / 2));
         ret.mul(t);
-        t.set(0, 0, (float)Math.sin(z/2), (float)Math.cos(z/2));
+        t.set(0, 0, (float) Math.sin(z / 2), (float) Math.cos(z / 2));
         ret.mul(t);
         return ret;
     }
 
-    public static Quat4f quatFromXYZDegrees(Vector3f xyz)
-    {
-        return quatFromXYZ((float)Math.toRadians(xyz.x), (float)Math.toRadians(xyz.y), (float)Math.toRadians(xyz.z));
+    public static Quat4f quatFromXYZDegrees(Vector3f xyz) {
+        return quatFromXYZ((float) Math.toRadians(xyz.x), (float) Math.toRadians(xyz.y), (float) Math.toRadians(xyz.z));
     }
 
-    public static Quat4f quatFromXYZ(Vector3f xyz)
-    {
+    public static Quat4f quatFromXYZ(Vector3f xyz) {
         return quatFromXYZ(xyz.x, xyz.y, xyz.z);
     }
 
-    public static Quat4f quatFromXYZ(float x, float y, float z)
-    {
+    public static Quat4f quatFromXYZ(float x, float y, float z) {
         Quat4f ret = new Quat4f(0, 0, 0, 1), t = new Quat4f();
-        t.set((float)Math.sin(x/2), 0, 0, (float)Math.cos(x/2));
+        t.set((float) Math.sin(x / 2), 0, 0, (float) Math.cos(x / 2));
         ret.mul(t);
-        t.set(0, (float)Math.sin(y/2), 0, (float)Math.cos(y/2));
+        t.set(0, (float) Math.sin(y / 2), 0, (float) Math.cos(y / 2));
         ret.mul(t);
-        t.set(0, 0, (float)Math.sin(z/2), (float)Math.cos(z/2));
+        t.set(0, 0, (float) Math.sin(z / 2), (float) Math.cos(z / 2));
         ret.mul(t);
         return ret;
     }
 
-    public static Vector3f toYXZDegrees(Quat4f q)
-    {
+    public static Vector3f toYXZDegrees(Quat4f q) {
         Vector3f yxz = toYXZ(q);
-        return new Vector3f((float)Math.toDegrees(yxz.x), (float)Math.toDegrees(yxz.y), (float)Math.toDegrees(yxz.z));
+        return new Vector3f((float) Math.toDegrees(yxz.x), (float) Math.toDegrees(yxz.y), (float) Math.toDegrees(yxz.z));
     }
 
-    public static Vector3f toYXZ(Quat4f q)
-    {
+    public static Vector3f toYXZ(Quat4f q) {
         float w2 = q.w * q.w;
         float x2 = q.x * q.x;
         float y2 = q.y * q.y;
         float z2 = q.z * q.z;
         float l = w2 + x2 + y2 + z2;
         float sx = 2 * q.w * q.x - 2 * q.y * q.z;
-        float x = (float)Math.asin(sx / l);
-        if(Math.abs(sx) > .999f * l)
-        {
+        float x = (float) Math.asin(sx / l);
+        if (Math.abs(sx) > .999f * l) {
             return new Vector3f(
-                 x,
-                 2 * (float)Math.atan2(q.y, q.w),
-                 0
+                    x,
+                    2 * (float) Math.atan2(q.y, q.w),
+                    0
             );
         }
         return new Vector3f(
-            x,
-            (float)Math.atan2(2 * q.x * q.z + 2 * q.y * q.w, w2 - x2 - y2 + z2),
-            (float)Math.atan2(2 * q.x * q.y + 2 * q.w * q.z, w2 - x2 + y2 - z2)
+                x,
+                (float) Math.atan2(2 * q.x * q.z + 2 * q.y * q.w, w2 - x2 - y2 + z2),
+                (float) Math.atan2(2 * q.x * q.y + 2 * q.w * q.z, w2 - x2 + y2 - z2)
         );
     }
 
-    public static Vector3f toXYZDegrees(Quat4f q)
-    {
+    public static Vector3f toXYZDegrees(Quat4f q) {
         Vector3f xyz = toXYZ(q);
-        return new Vector3f((float)Math.toDegrees(xyz.x), (float)Math.toDegrees(xyz.y), (float)Math.toDegrees(xyz.z));
+        return new Vector3f((float) Math.toDegrees(xyz.x), (float) Math.toDegrees(xyz.y), (float) Math.toDegrees(xyz.z));
     }
 
-    public static Vector3f toXYZ(Quat4f q)
-    {
+    public static Vector3f toXYZ(Quat4f q) {
         float w2 = q.w * q.w;
         float x2 = q.x * q.x;
         float y2 = q.y * q.y;
         float z2 = q.z * q.z;
         float l = w2 + x2 + y2 + z2;
         float sy = 2 * q.w * q.x - 2 * q.y * q.z;
-        float y = (float)Math.asin(sy / l);
-        if(Math.abs(sy) > .999f * l)
-        {
+        float y = (float) Math.asin(sy / l);
+        if (Math.abs(sy) > .999f * l) {
             return new Vector3f(
-                 2 * (float)Math.atan2(q.x, q.w),
-                 y,
-                 0
+                    2 * (float) Math.atan2(q.x, q.w),
+                    y,
+                    0
             );
         }
         return new Vector3f(
-            (float)Math.atan2(2 * q.y * q.z + 2 * q.x * q.w, w2 - x2 - y2 + z2),
-            y,
-            (float)Math.atan2(2 * q.x * q.y + 2 * q.w * q.z, w2 + x2 - y2 - z2)
+                (float) Math.atan2(2 * q.y * q.z + 2 * q.x * q.w, w2 - x2 - y2 + z2),
+                y,
+                (float) Math.atan2(2 * q.x * q.y + 2 * q.w * q.z, w2 + x2 - y2 - z2)
         );
     }
 
-    public static Matrix4f mul(@Nullable Vector3f translation, @Nullable Quat4f leftRot, @Nullable Vector3f scale, @Nullable Quat4f rightRot)
-    {
+    public static Matrix4f mul(@Nullable Vector3f translation, @Nullable Quat4f leftRot, @Nullable Vector3f scale, @Nullable Quat4f rightRot) {
         Matrix4f res = new Matrix4f(), t = new Matrix4f();
         res.setIdentity();
-        if(leftRot != null)
-        {
+        if (leftRot != null) {
             t.set(leftRot);
             res.mul(t);
         }
-        if(scale != null)
-        {
+        if (scale != null) {
             t.setIdentity();
             t.m00 = scale.x;
             t.m11 = scale.y;
             t.m22 = scale.z;
             res.mul(t);
         }
-        if(rightRot != null)
-        {
+        if (rightRot != null) {
             t.set(rightRot);
             res.mul(t);
         }
-        if(translation != null) res.setTranslation(translation);
+        if (translation != null) res.setTranslation(translation);
         return res;
     }
 
     /*
      * Performs SVD decomposition of m, accumulating reflection in the scale (U and V are pure rotations).
      */
-    public static Triple<Quat4f, Vector3f, Quat4f> svdDecompose(Matrix3f m)
-    {
+    public static Triple<Quat4f, Vector3f, Quat4f> svdDecompose(Matrix3f m) {
         // determine V by doing 5 steps of Jacobi iteration on MT * M
         Quat4f u = new Quat4f(0, 0, 0, 1), v = new Quat4f(0, 0, 0, 1), qt = new Quat4f();
         Matrix3f b = new Matrix3f(m), t = new Matrix3f();
         t.transpose(m);
         b.mul(t, b);
 
-        for(int i = 0; i < 5; i++) v.mul(stepJacobi(b));
+        for (int i = 0; i < 5; i++) v.mul(stepJacobi(b));
 
         v.normalize();
         t.set(v);
@@ -387,15 +343,14 @@
         b.mul(t, b);
 
         ul = 1f / ul;
-        u.scale((float)Math.sqrt(ul));
+        u.scale((float) Math.sqrt(ul));
 
         Vector3f s = new Vector3f(b.m00 * ul, b.m11 * ul, b.m22 * ul);
 
         return Triple.of(u, s, v);
     }
 
-    private static float rsqrt(float f)
-    {
+    private static float rsqrt(float f) {
         float f2 = .5f * f;
         int i = Float.floatToIntBits(f);
         i = 0x5f3759df - (i >> 1);
@@ -404,14 +359,7 @@
         return f;
     }
 
-    private static final float eps = 1e-6f;
-    private static final float g = 3f + 2f * (float)Math.sqrt(2);
-    private static final float cs = (float)Math.cos(Math.PI / 8);
-    private static final float ss = (float)Math.sin(Math.PI / 8);
-    private static final float sq2 = 1f / (float)Math.sqrt(2);
-
-    private static Pair<Float, Float> approxGivensQuat(float a11, float a12, float a22)
-    {
+    private static Pair<Float, Float> approxGivensQuat(float a11, float a12, float a22) {
         float ch = 2f * (a11 - a22);
         float sh = a12;
         boolean b = g * sh * sh < ch * ch;
@@ -421,26 +369,22 @@
         return Pair.of(sh, ch);
     }
 
-    private static final void swapNeg(Matrix3f m, int i, int j)
-    {
+    private static final void swapNeg(Matrix3f m, int i, int j) {
         float[] t = new float[3];
         m.getColumn(j, t);
-        for(int k = 0; k < 3; k++)
-        {
+        for (int k = 0; k < 3; k++) {
             m.setElement(k, j, -m.getElement(k, i));
         }
         m.setColumn(i, t);
     }
 
     @SuppressWarnings("unused")
-    private static void sortSingularValues(Matrix3f b, Quat4f v)
-    {
+    private static void sortSingularValues(Matrix3f b, Quat4f v) {
         float p0 = b.m00 * b.m00 + b.m10 * b.m10 + b.m20 * b.m20;
         float p1 = b.m01 * b.m01 + b.m11 * b.m11 + b.m21 * b.m21;
         float p2 = b.m02 * b.m02 + b.m12 * b.m12 + b.m22 * b.m22;
         Quat4f t = new Quat4f();
-        if(p0 < p1)
-        {
+        if (p0 < p1) {
             swapNeg(b, 0, 1);
             t.set(0, 0, sq2, sq2);
             v.mul(t);
@@ -448,8 +392,7 @@
             p0 = p1;
             p1 = f;
         }
-        if(p0 < p2)
-        {
+        if (p0 < p2) {
             swapNeg(b, 0, 2);
             t.set(0, sq2, 0, sq2);
             v.mul(t);
@@ -457,21 +400,18 @@
             p0 = p2;
             p2 = f;
         }
-        if(p1 < p2)
-        {
+        if (p1 < p2) {
             swapNeg(b, 1, 2);
             t.set(sq2, 0, 0, sq2);
             v.mul(t);
         }
     }
 
-    private static Pair<Float, Float> qrGivensQuat(float a1, float a2)
-    {
-        float p = (float)Math.sqrt(a1 * a1 + a2 * a2);
+    private static Pair<Float, Float> qrGivensQuat(float a1, float a2) {
+        float p = (float) Math.sqrt(a1 * a1 + a2 * a2);
         float sh = p > eps ? a2 : 0;
         float ch = Math.abs(a1) + Math.max(p, eps);
-        if(a1 < 0)
-        {
+        if (a1 < 0) {
             float f = sh;
             sh = ch;
             ch = f;
@@ -483,14 +423,12 @@
         return Pair.of(sh, ch);
     }
 
-    private static Quat4f stepJacobi(Matrix3f m)
-    {
+    private static Quat4f stepJacobi(Matrix3f m) {
         Matrix3f t = new Matrix3f();
         Quat4f qt = new Quat4f(), ret = new Quat4f(0, 0, 0, 1);
         Pair<Float, Float> p;
         // 01
-        if(m.m01 * m.m01 + m.m10 * m.m10 > eps)
-        {
+        if (m.m01 * m.m01 + m.m10 * m.m10 > eps) {
             p = approxGivensQuat(m.m00, .5f * (m.m01 + m.m10), m.m11);
             qt.set(0, 0, p.getLeft(), p.getRight());
             //qt.normalize();
@@ -507,8 +445,7 @@
             m.mul(t, m);
         }
         // 02
-        if(m.m02 * m.m02 + m.m20 * m.m20 > eps)
-        {
+        if (m.m02 * m.m02 + m.m20 * m.m20 > eps) {
             p = approxGivensQuat(m.m00, .5f * (m.m02 + m.m20), m.m22);
             qt.set(0, -p.getLeft(), 0, p.getRight());
             //qt.normalize();
@@ -525,8 +462,7 @@
             m.mul(t, m);
         }
         // 12
-        if(m.m12 * m.m12 + m.m21 * m.m21 > eps)
-        {
+        if (m.m12 * m.m12 + m.m21 * m.m21 > eps) {
             p = approxGivensQuat(m.m11, .5f * (m.m12 + m.m21), m.m22);
             qt.set(p.getLeft(), 0, 0, p.getRight());
             //qt.normalize();
@@ -548,149 +484,39 @@
     /*
      * Divides m by m33, sets last row to (0, 0, 0, 1), extracts linear and translation parts
      */
-    public static Pair<Matrix3f, Vector3f> toAffine(Matrix4f m)
-    {
+    public static Pair<Matrix3f, Vector3f> toAffine(Matrix4f m) {
         m.mul(1.f / m.m33);
         Vector3f trans = new Vector3f(m.m03, m.m13, m.m23);
         Matrix3f linear = new Matrix3f(m.m00, m.m01, m.m02, m.m10, m.m11, m.m12, m.m20, m.m21, m.m22);
         return Pair.of(linear, trans);
     }
 
-    /*
-     * Don't use this if you don't need to, conversion is lossy (second rotation component is lost).
-     */
-    @Deprecated
-    @SideOnly(Side.CLIENT)
-    public ItemTransformVec3f toItemTransform()
-    {
-        return new ItemTransformVec3f(toLwjgl(toXYZDegrees(getLeftRot())), toLwjgl(getTranslation()), toLwjgl(getScale()));
-    }
-
-    public boolean isIdentity()
-    {
-        return this.equals(identity);
-    }
-
-    @Override
-    public Matrix4f getMatrix()
-    {
-        return (Matrix4f)matrix.clone();
-    }
-
-    public Vector3f getTranslation()
-    {
-        genCheck();
-        return (Vector3f)translation.clone();
-    }
-
-    public Quat4f getLeftRot()
-    {
-        genCheck();
-        return (Quat4f)leftRot.clone();
-    }
-
-    public Vector3f getScale()
-    {
-        genCheck();
-        return (Vector3f)scale.clone();
-    }
-
-    public Quat4f getRightRot()
-    {
-        genCheck();
-        return (Quat4f)rightRot.clone();
-    }
-
-    @Override
-    public Optional<TRSRTransformation> apply(Optional<? extends IModelPart> part)
-    {
-        if(part.isPresent())
-        {
-            return Optional.empty();
-        }
-        return Optional.of(this);
-    }
-
-    @Override
-    public EnumFacing rotate(EnumFacing facing)
-    {
-        return rotate(matrix, facing);
-    }
-
-    public static EnumFacing rotate(Matrix4f matrix, EnumFacing facing)
-    {
+    public static EnumFacing rotate(Matrix4f matrix, EnumFacing facing) {
         Vec3i dir = facing.getDirectionVec();
         Vector4f vec = new Vector4f(dir.getX(), dir.getY(), dir.getZ(), 0);
         matrix.transform(vec);
         return EnumFacing.getFacingFromVector(vec.x, vec.y, vec.z);
     }
 
-    public static boolean isInteger(Matrix4f matrix)
-    {
+    public static boolean isInteger(Matrix4f matrix) {
         Matrix4f m = new Matrix4f();
         m.setIdentity();
         m.m30 = m.m31 = m.m32 = 1;
         m.m33 = 0;
         m.mul(matrix, m);
-        for(int i = 0; i < 3; i++)
-        {
-            for(int j = 0; j < 3; j++)
-            {
+        for (int i = 0; i < 3; i++) {
+            for (int j = 0; j < 3; j++) {
                 float v = m.getElement(i, j) / m.getElement(3, j);
-                if(Math.abs(v - Math.round(v)) > 1e-5) return false;
+                if (Math.abs(v - Math.round(v)) > 1e-5) return false;
             }
         }
         return true;
     }
 
-    @Override
-    public int rotate(EnumFacing facing, int vertexIndex)
-    {
-        // FIXME check if this is good enough
-        return vertexIndex;
-    }
-
-    public void transformPosition(Vector4f position)
-    {
-        matrix.transform(position);
-    }
-
-    public void transformNormal(Vector3f normal)
-    {
-        checkNormalTransform();
-        normalTransform.transform(normal);
-        normal.normalize();
-    }
-
-    private void checkNormalTransform()
-    {
-        if (normalTransform == null)
-        {
-            normalTransform = new Matrix3f();
-            matrix.getRotationScale(normalTransform);
-            normalTransform.invert();
-            normalTransform.transpose();
-        }
-    }
-
-    @Override
-    public String toString()
-    {
-        genCheck();
-        return MoreObjects.toStringHelper(this.getClass())
-            .add("matrix", matrix)
-            .add("translation", translation)
-            .add("leftRot", leftRot)
-            .add("scale", scale)
-            .add("rightRot", rightRot)
-            .toString();
-    }
-
     /**
      * convert transformation from assuming center-block system to corner-block system
      */
-    public static TRSRTransformation blockCenterToCorner(TRSRTransformation transform)
-    {
+    public static TRSRTransformation blockCenterToCorner(TRSRTransformation transform) {
         if (transform.isIdentity()) return transform;
 
         Matrix4f ret = new Matrix4f(transform.getMatrix()), tmp = new Matrix4f();
@@ -705,8 +531,7 @@
     /**
      * convert transformation from assuming corner-block system to center-block system
      */
-    public static TRSRTransformation blockCornerToCenter(TRSRTransformation transform)
-    {
+    public static TRSRTransformation blockCornerToCenter(TRSRTransformation transform) {
         if (transform.isIdentity()) return transform;
 
         Matrix4f ret = new Matrix4f(transform.getMatrix()), tmp = new Matrix4f();
@@ -718,62 +543,37 @@
         return new TRSRTransformation(ret);
     }
 
-    @Override
-    public int hashCode()
-    {
-        final int prime = 31;
-        int result = 1;
-        result = prime * result + Objects.hashCode(matrix);
-        return result;
-    }
-
-    @Override
-    public boolean equals(Object obj)
-    {
-        if (this == obj) return true;
-        if (obj == null) return false;
-        if (getClass() != obj.getClass()) return false;
-        TRSRTransformation other = (TRSRTransformation) obj;
-        return Objects.equals(matrix, other.matrix);
-    }
-
     @SideOnly(Side.CLIENT)
-    public static Vector3f toVecmath(org.lwjgl.util.vector.Vector3f vec)
-    {
+    public static Vector3f toVecmath(org.lwjgl.util.vector.Vector3f vec) {
         return new Vector3f(vec.x, vec.y, vec.z);
     }
 
     @SideOnly(Side.CLIENT)
-    public static Vector4f toVecmath(org.lwjgl.util.vector.Vector4f vec)
-    {
+    public static Vector4f toVecmath(org.lwjgl.util.vector.Vector4f vec) {
         return new Vector4f(vec.x, vec.y, vec.z, vec.w);
     }
 
     @SideOnly(Side.CLIENT)
-    public static Matrix4f toVecmath(org.lwjgl.util.vector.Matrix4f m)
-    {
+    public static Matrix4f toVecmath(org.lwjgl.util.vector.Matrix4f m) {
         return new Matrix4f(
-            m.m00, m.m10, m.m20, m.m30,
-            m.m01, m.m11, m.m21, m.m31,
-            m.m02, m.m12, m.m22, m.m32,
-            m.m03, m.m13, m.m23, m.m33);
+                m.m00, m.m10, m.m20, m.m30,
+                m.m01, m.m11, m.m21, m.m31,
+                m.m02, m.m12, m.m22, m.m32,
+                m.m03, m.m13, m.m23, m.m33);
     }
 
     @SideOnly(Side.CLIENT)
-    public static org.lwjgl.util.vector.Vector3f toLwjgl(Vector3f vec)
-    {
+    public static org.lwjgl.util.vector.Vector3f toLwjgl(Vector3f vec) {
         return new org.lwjgl.util.vector.Vector3f(vec.x, vec.y, vec.z);
     }
 
     @SideOnly(Side.CLIENT)
-    public static org.lwjgl.util.vector.Vector4f toLwjgl(Vector4f vec)
-    {
+    public static org.lwjgl.util.vector.Vector4f toLwjgl(Vector4f vec) {
         return new org.lwjgl.util.vector.Vector4f(vec.x, vec.y, vec.z, vec.w);
     }
 
     @SideOnly(Side.CLIENT)
-    public static org.lwjgl.util.vector.Matrix4f toLwjgl(Matrix4f m)
-    {
+    public static org.lwjgl.util.vector.Matrix4f toLwjgl(Matrix4f m) {
         org.lwjgl.util.vector.Matrix4f r = new org.lwjgl.util.vector.Matrix4f();
         r.m00 = m.m00;
         r.m01 = m.m10;
@@ -794,96 +594,191 @@
         return r;
     }
 
-    public static Vector3f lerp(Tuple3f from, Tuple3f to, float progress)
-    {
+    public static Vector3f lerp(Tuple3f from, Tuple3f to, float progress) {
         Vector3f res = new Vector3f(from);
         res.interpolate(from, to, progress);
         return res;
     }
 
-    public static Vector4f lerp(Tuple4f from, Tuple4f to, float progress)
-    {
+    public static Vector4f lerp(Tuple4f from, Tuple4f to, float progress) {
         Vector4f res = new Vector4f(from);
         res.interpolate(from, to, progress);
         return res;
     }
 
-    public static Quat4f slerp(Quat4f from, Quat4f to, float progress)
-    {
+    public static Quat4f slerp(Quat4f from, Quat4f to, float progress) {
         Quat4f res = new Quat4f();
         res.interpolate(from, to, progress);
         return res;
     }
 
-    public TRSRTransformation slerp(TRSRTransformation that, float progress)
-    {
-        return new TRSRTransformation(
-            lerp(this.getTranslation(), that.getTranslation(), progress),
-            slerp(this.getLeftRot(), that.getLeftRot(), progress),
-            lerp(this.getScale(), that.getScale(), progress),
-            slerp(this.getRightRot(), that.getRightRot(), progress)
-        );
+    public static TRSRTransformation getVanillaUvTransformLocalToGlobal(EnumFacing side) {
+        return vanillaUvTransformLocalToGlobal.get(side);
     }
 
-    private static final EnumMap<EnumFacing, TRSRTransformation> vanillaUvTransformLocalToGlobal = Maps.newEnumMap(EnumFacing.class);
-    private static final EnumMap<EnumFacing, TRSRTransformation> vanillaUvTransformGlobalToLocal = Maps.newEnumMap(EnumFacing.class);
+    public static TRSRTransformation getVanillaUvTransformGlobalToLocal(EnumFacing side) {
+        return vanillaUvTransformGlobalToLocal.get(side);
+    }
 
-    static
-    {
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.SOUTH, identity);
-        Quat4f tmp = new Quat4f();
-        tmp.set(new AxisAngle4f(0, 1, 0, (float)Math.toRadians(90)));
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.EAST,  new TRSRTransformation(null, new Quat4f(tmp), null, null));
-        tmp.set(new AxisAngle4f(0, 1, 0, (float)Math.toRadians(-90)));
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.WEST,  new TRSRTransformation(null, new Quat4f(tmp), null, null));
-        tmp.set(new AxisAngle4f(0, 1, 0, (float)Math.toRadians(180)));
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.NORTH, new TRSRTransformation(null, new Quat4f(tmp), null, null));
-        tmp.set(new AxisAngle4f(1, 0, 0, (float)Math.toRadians(-90)));
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.UP,    new TRSRTransformation(null, new Quat4f(tmp), null, null));
-        tmp.set(new AxisAngle4f(1, 0, 0, (float)Math.toRadians(90)));
-        vanillaUvTransformLocalToGlobal.put(EnumFacing.DOWN,  new TRSRTransformation(null, new Quat4f(tmp), null, null));
+    public TRSRTransformation compose(TRSRTransformation b) {
+        if (this.isIdentity()) return b;
+        if (b.isIdentity()) return this;
+        Matrix4f m = getMatrix();
+        m.mul(b.getMatrix());
+        return new TRSRTransformation(m);
+    }
 
-        for(EnumFacing side : EnumFacing.values())
-        {
-            vanillaUvTransformGlobalToLocal.put(side, vanillaUvTransformLocalToGlobal.get(side).inverse());
+    public TRSRTransformation inverse() {
+        if (this.isIdentity()) return this;
+        Matrix4f m = getMatrix();
+        m.invert();
+        return new TRSRTransformation(m);
+    }
+
+    private void genCheck() {
+        if (!full) {
+            Pair<Matrix3f, Vector3f> pair = toAffine(matrix);
+            Triple<Quat4f, Vector3f, Quat4f> triple = svdDecompose(pair.getLeft());
+            this.translation = pair.getRight();
+            this.leftRot = triple.getLeft();
+            this.scale = triple.getMiddle();
+            this.rightRot = triple.getRight();
+            full = true;
         }
     }
 
-    public static TRSRTransformation getVanillaUvTransformLocalToGlobal(EnumFacing side)
-    {
-        return vanillaUvTransformLocalToGlobal.get(side);
+    /*
+     * Don't use this if you don't need to, conversion is lossy (second rotation component is lost).
+     */
+    @Deprecated
+    @SideOnly(Side.CLIENT)
+    public ItemTransformVec3f toItemTransform() {
+        return new ItemTransformVec3f(toLwjgl(toXYZDegrees(getLeftRot())), toLwjgl(getTranslation()), toLwjgl(getScale()));
     }
 
-    public static TRSRTransformation getVanillaUvTransformGlobalToLocal(EnumFacing side)
-    {
-        return vanillaUvTransformGlobalToLocal.get(side);
+    public boolean isIdentity() {
+        return this.equals(identity);
     }
 
-    public TRSRTransformation getUVLockTransform(EnumFacing originalSide)
-    {
+    @Override
+    public Matrix4f getMatrix() {
+        return (Matrix4f) matrix.clone();
+    }
+
+    public Vector3f getTranslation() {
+        genCheck();
+        return (Vector3f) translation.clone();
+    }
+
+    public Quat4f getLeftRot() {
+        genCheck();
+        return (Quat4f) leftRot.clone();
+    }
+
+    public Vector3f getScale() {
+        genCheck();
+        return (Vector3f) scale.clone();
+    }
+
+    public Quat4f getRightRot() {
+        genCheck();
+        return (Quat4f) rightRot.clone();
+    }
+
+    @Override
+    public Optional<TRSRTransformation> apply(Optional<? extends IModelPart> part) {
+        if (part.isPresent()) {
+            return Optional.empty();
+        }
+        return Optional.of(this);
+    }
+
+    @Override
+    public EnumFacing rotate(EnumFacing facing) {
+        return rotate(matrix, facing);
+    }
+
+    @Override
+    public int rotate(EnumFacing facing, int vertexIndex) {
+        // FIXME check if this is good enough
+        return vertexIndex;
+    }
+
+    public void transformPosition(Vector4f position) {
+        matrix.transform(position);
+    }
+
+    public void transformNormal(Vector3f normal) {
+        checkNormalTransform();
+        normalTransform.transform(normal);
+        normal.normalize();
+    }
+
+    private void checkNormalTransform() {
+        if (normalTransform == null) {
+            normalTransform = new Matrix3f();
+            matrix.getRotationScale(normalTransform);
+            normalTransform.invert();
+            normalTransform.transpose();
+        }
+    }
+
+    @Override
+    public String toString() {
+        genCheck();
+        return MoreObjects.toStringHelper(this.getClass())
+                .add("matrix", matrix)
+                .add("translation", translation)
+                .add("leftRot", leftRot)
+                .add("scale", scale)
+                .add("rightRot", rightRot)
+                .toString();
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + Objects.hashCode(matrix);
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) return true;
+        if (obj == null) return false;
+        if (getClass() != obj.getClass()) return false;
+        TRSRTransformation other = (TRSRTransformation) obj;
+        return Objects.equals(matrix, other.matrix);
+    }
+
+    public TRSRTransformation slerp(TRSRTransformation that, float progress) {
+        return new TRSRTransformation(
+                lerp(this.getTranslation(), that.getTranslation(), progress),
+                slerp(this.getLeftRot(), that.getLeftRot(), progress),
+                lerp(this.getScale(), that.getScale(), progress),
+                slerp(this.getRightRot(), that.getRightRot(), progress)
+        );
+    }
+
+    public TRSRTransformation getUVLockTransform(EnumFacing originalSide) {
         EnumFacing newSide = rotate(originalSide);
-        try
-        {
+        try {
             return blockCenterToCorner(vanillaUvTransformGlobalToLocal.get(originalSide).compose(blockCornerToCenter(this.inverse())).compose(vanillaUvTransformLocalToGlobal.get(newSide)));
-        }
-        catch(SingularMatrixException e)
-        {
+        } catch (SingularMatrixException e) {
             return new TRSRTransformation(null, null, new Vector3f(0, 0, 0), null);
         }
     }
 
     @SideOnly(Side.CLIENT)
-    private static final class Cache
-    {
+    private static final class Cache {
         private static final Map<ModelRotation, TRSRTransformation> rotations = new EnumMap<>(ModelRotation.class);
 
-        static
-        {
+        static {
             rotations.put(ModelRotation.X0_Y0, identity());
         }
 
-        static TRSRTransformation get(ModelRotation rotation)
-        {
+        static TRSRTransformation get(ModelRotation rotation) {
             return rotations.computeIfAbsent(rotation, r -> new TRSRTransformation(ForgeHooksClient.getMatrix(r)));
         }
     }

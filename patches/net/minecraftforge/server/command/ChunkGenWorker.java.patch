--- ../src-base/minecraft/net/minecraftforge/server/command/ChunkGenWorker.java
+++ ../src-work/minecraft/net/minecraftforge/server/command/ChunkGenWorker.java
@@ -19,10 +19,6 @@
 
 package net.minecraftforge.server.command;
 
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Queue;
-
 import net.minecraft.command.ICommandSender;
 import net.minecraft.server.management.PlayerChunkMapEntry;
 import net.minecraft.util.math.BlockPos;
@@ -35,11 +31,14 @@
 import net.minecraftforge.common.DimensionManager;
 import net.minecraftforge.common.WorldWorkerManager.IWorker;
 
-public class ChunkGenWorker implements IWorker
-{
-    private final ICommandSender listener;
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Queue;
+
+public class ChunkGenWorker implements IWorker {
     protected final BlockPos start;
     protected final int total;
+    private final ICommandSender listener;
     private final int dim;
     private final Queue<BlockPos> queue;
     private final int notificationFrequency;
@@ -48,26 +47,23 @@
     private int genned = 0;
     private Boolean keepingLoaded;
 
-    public ChunkGenWorker(ICommandSender listener, BlockPos start, int total, int dim, int interval)
-    {
+    public ChunkGenWorker(ICommandSender listener, BlockPos start, int total, int dim, int interval) {
         this.listener = listener;
         this.start = start;
         this.total = total;
-        this.dim  = dim;
+        this.dim = dim;
         this.queue = buildQueue();
         this.notificationFrequency = interval != -1 ? interval : Math.max(total / 20, 100); //Every 5% or every 100, whichever is more.
         this.lastNotifcationTime = System.currentTimeMillis(); //We also notify at least once every 60 seconds, to show we haven't froze.
     }
 
-    protected Queue<BlockPos> buildQueue()
-    {
+    protected Queue<BlockPos> buildQueue() {
         Queue<BlockPos> ret = new ArrayDeque<BlockPos>();
         ret.add(start);
 
         //This *should* spiral outwards, starting on right side, down, left, up, right, but hey we'll see!
         int radius = 1;
-        while (ret.size() < total)
-        {
+        while (ret.size() < total) {
             for (int q = -radius + 1; q <= radius && ret.size() < total; q++)
                 ret.add(start.add(radius, 0, q));
 
@@ -86,44 +82,36 @@
     }
 
     @Deprecated // TODO remove in 1.13
-    public TextComponentTranslation getStartMessage()
-    {
+    public TextComponentTranslation getStartMessage() {
         return new TextComponentTranslation("commands.forge.gen.start", total, start.getX(), start.getZ(), dim);
     }
 
-    public TextComponentBase getStartMessage(ICommandSender sender)
-    {
+    public TextComponentBase getStartMessage(ICommandSender sender) {
         return TextComponentHelper.createComponentTranslation(sender, "commands.forge.gen.start", total, start.getX(), start.getZ(), dim);
     }
 
     @Override
-    public boolean hasWork()
-    {
+    public boolean hasWork() {
         return queue.size() > 0;
     }
 
     @Override
-    public boolean doWork()
-    {
+    public boolean doWork() {
         WorldServer world = DimensionManager.getWorld(dim);
-        if (world == null)
-        {
+        if (world == null) {
             DimensionManager.initDimension(dim);
             world = DimensionManager.getWorld(dim);
-            if (world == null)
-            {
+            if (world == null) {
                 listener.sendMessage(TextComponentHelper.createComponentTranslation(listener, "commands.forge.gen.dim_fail", dim));
                 queue.clear();
                 return false;
             }
         }
 
-        AnvilChunkLoader loader = world.getChunkProvider().chunkLoader instanceof AnvilChunkLoader ? (AnvilChunkLoader)world.getChunkProvider().chunkLoader : null;
-        if (loader != null && loader.getPendingSaveCount() > 100)
-        {
+        AnvilChunkLoader loader = world.getChunkProvider().chunkLoader instanceof AnvilChunkLoader ? (AnvilChunkLoader) world.getChunkProvider().chunkLoader : null;
+        if (loader != null && loader.getPendingSaveCount() > 100) {
 
-            if (lastNotifcationTime < System.currentTimeMillis() - 10*1000)
-            {
+            if (lastNotifcationTime < System.currentTimeMillis() - 10 * 1000) {
                 listener.sendMessage(TextComponentHelper.createComponentTranslation(listener, "commands.forge.gen.progress", total - queue.size(), total));
                 lastNotifcationTime = System.currentTimeMillis();
             }
@@ -132,16 +120,13 @@
 
         BlockPos next = queue.poll();
 
-        if (next != null)
-        {
+        if (next != null) {
             // While we work we don't want to cause world load spam so pause unloading the world.
-            if (keepingLoaded == null)
-            {
+            if (keepingLoaded == null) {
                 keepingLoaded = DimensionManager.keepDimensionLoaded(dim, true);
             }
 
-            if (++lastNotification >= notificationFrequency || lastNotifcationTime < System.currentTimeMillis() - 60*1000)
-            {
+            if (++lastNotification >= notificationFrequency || lastNotifcationTime < System.currentTimeMillis() - 60 * 1000) {
                 listener.sendMessage(TextComponentHelper.createComponentTranslation(listener, "commands.forge.gen.progress", total - queue.size(), total));
                 lastNotification = 0;
                 lastNotifcationTime = System.currentTimeMillis();
@@ -151,25 +136,21 @@
             int z = next.getZ();
 
             Chunk target = world.getChunkFromChunkCoords(x, z);
-            Chunk[] chunks = { target };
+            Chunk[] chunks = {target};
 
-            if (!target.isTerrainPopulated())
-            {
+            if (!target.isTerrainPopulated()) {
                 // In order for a chunk to populate, The chunks around its bottom right corner need to be loaded.
                 // So lets load those chunks, but this needs to be done in a certain order to make this trigger.
                 // So this does load more chunks then it should, and is a hack, but lets go!.
-                chunks = new Chunk[] {
-                    target,
-                    world.getChunkFromChunkCoords(x + 1, z),
-                    world.getChunkFromChunkCoords(x + 1, z + 1),
-                    world.getChunkFromChunkCoords(x,     z + 1),
+                chunks = new Chunk[]{
+                        target,
+                        world.getChunkFromChunkCoords(x + 1, z),
+                        world.getChunkFromChunkCoords(x + 1, z + 1),
+                        world.getChunkFromChunkCoords(x, z + 1),
                 };
-                try
-                {
+                try {
                     world.getChunkProvider().chunkLoader.saveChunk(world, target);
-                }
-                catch (IOException | MinecraftException e)
-                {
+                } catch (IOException | MinecraftException e) {
                     listener.sendMessage(TextComponentHelper.createComponentTranslation(listener, "commands.forge.gen.saveerror", e.getMessage()));
                 }
                 genned++;
@@ -183,11 +164,9 @@
             }
         }
 
-        if (queue.size() == 0)
-        {
+        if (queue.size() == 0) {
             listener.sendMessage(TextComponentHelper.createComponentTranslation(listener, "commands.forge.gen.complete", genned, total, dim));
-            if (keepingLoaded != null && keepingLoaded)
-            {
+            if (keepingLoaded != null && keepingLoaded) {
                 DimensionManager.keepDimensionLoaded(dim, false);
             }
             return false;

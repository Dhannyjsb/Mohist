--- ../src-base/minecraft/net/minecraftforge/fml/repackage/com/nothome/delta/GDiffPatcher.java
+++ ../src-work/minecraft/net/minecraftforge/fml/repackage/com/nothome/delta/GDiffPatcher.java
@@ -27,32 +27,11 @@
 
 import org.apache.commons.io.IOUtils;
 
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_INT_INT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_INT_UBYTE;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_INT_USHORT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_LONG_INT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_USHORT_INT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_USHORT_UBYTE;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.COPY_USHORT_USHORT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.DATA_INT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.DATA_MAX;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.DATA_USHORT;
-import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.EOF;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.RandomAccessFile;
+import java.io.*;
 import java.nio.ByteBuffer;
 
+import static net.minecraftforge.fml.repackage.com.nothome.delta.GDiffWriter.*;
+
 /**
  * This class patches an input file with a GDIFF patch file.
  *
@@ -72,12 +51,42 @@
     }
 
     /**
+     * Simple command line tool to patch a file.
+     */
+    public static void main(String argv[]) {
+
+        if (argv.length != 3) {
+            System.err.println("usage GDiffPatch source patch output");
+            System.err.println("aborting..");
+            return;
+        }
+        try {
+            File sourceFile = new File(argv[0]);
+            File patchFile = new File(argv[1]);
+            File outputFile = new File(argv[2]);
+
+            if (sourceFile.length() > Integer.MAX_VALUE ||
+                    patchFile.length() > Integer.MAX_VALUE) {
+                System.err.println("source or patch is too large, max length is " + Integer.MAX_VALUE);
+                System.err.println("aborting..");
+                return;
+            }
+            GDiffPatcher patcher = new GDiffPatcher();
+            patcher.patch(sourceFile, patchFile, outputFile);
+
+            System.out.println("finished patching file");
+
+        } catch (Exception ioe) {                                   //gls031504a
+            System.err.println("error while patching: " + ioe);
+        }
+    }
+
+    /**
      * Patches to an output file.
      */
     public void patch(File sourceFile, File patchFile, File outputFile)
-		throws IOException
-	{
-        RandomAccessFileSeekableSource source =new RandomAccessFileSeekableSource(new RandomAccessFile(sourceFile, "r"));
+            throws IOException {
+        RandomAccessFileSeekableSource source = new RandomAccessFileSeekableSource(new RandomAccessFile(sourceFile, "r"));
         InputStream patch = null;
         OutputStream output = null;
         try {
@@ -138,59 +147,58 @@
             }
 
             switch (command) {
-            case DATA_USHORT: // ushort, n bytes following; append
-                length = patchIS.readUnsignedShort();
-                append(length, patchIS, outOS);
-                break;
-            case DATA_INT: // int, n bytes following; append
-                length = patchIS.readInt();
-                append(length, patchIS, outOS);
-                break;
-            case COPY_USHORT_UBYTE:
-                offset = patchIS.readUnsignedShort();
-                length = patchIS.readUnsignedByte();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_USHORT_USHORT:
-                offset = patchIS.readUnsignedShort();
-                length = patchIS.readUnsignedShort();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_USHORT_INT:
-                offset = patchIS.readUnsignedShort();
-                length = patchIS.readInt();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_INT_UBYTE:
-                offset = patchIS.readInt();
-                length = patchIS.readUnsignedByte();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_INT_USHORT:
-                offset = patchIS.readInt();
-                length = patchIS.readUnsignedShort();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_INT_INT:
-                offset = patchIS.readInt();
-                length = patchIS.readInt();
-                copy(offset, length, source, outOS);
-                break;
-            case COPY_LONG_INT:
-                long loffset = patchIS.readLong();
-                length = patchIS.readInt();
-                copy(loffset, length, source, outOS);
-                break;
-            default:
-                throw new IllegalStateException("command " + command);
+                case DATA_USHORT: // ushort, n bytes following; append
+                    length = patchIS.readUnsignedShort();
+                    append(length, patchIS, outOS);
+                    break;
+                case DATA_INT: // int, n bytes following; append
+                    length = patchIS.readInt();
+                    append(length, patchIS, outOS);
+                    break;
+                case COPY_USHORT_UBYTE:
+                    offset = patchIS.readUnsignedShort();
+                    length = patchIS.readUnsignedByte();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_USHORT_USHORT:
+                    offset = patchIS.readUnsignedShort();
+                    length = patchIS.readUnsignedShort();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_USHORT_INT:
+                    offset = patchIS.readUnsignedShort();
+                    length = patchIS.readInt();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_INT_UBYTE:
+                    offset = patchIS.readInt();
+                    length = patchIS.readUnsignedByte();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_INT_USHORT:
+                    offset = patchIS.readInt();
+                    length = patchIS.readUnsignedShort();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_INT_INT:
+                    offset = patchIS.readInt();
+                    length = patchIS.readInt();
+                    copy(offset, length, source, outOS);
+                    break;
+                case COPY_LONG_INT:
+                    long loffset = patchIS.readLong();
+                    length = patchIS.readInt();
+                    copy(loffset, length, source, outOS);
+                    break;
+                default:
+                    throw new IllegalStateException("command " + command);
             }
         }
-		outOS.flush();
+        outOS.flush();
     }
 
     private void copy(long offset, int length, SeekableSource source, OutputStream output)
-		throws IOException
-	{
+            throws IOException {
         source.seek(offset);
         while (length > 0) {
             int len = Math.min(buf.capacity(), length);
@@ -206,43 +214,12 @@
     private void append(int length, InputStream patch, OutputStream output) throws IOException {
         while (length > 0) {
             int len = Math.min(buf2.length, length);
-    	    int res = patch.read(buf2, 0, len);
-    	    if (res == -1)
-    	        throw new EOFException("cannot read " + length);
+            int res = patch.read(buf2, 0, len);
+            if (res == -1)
+                throw new EOFException("cannot read " + length);
             output.write(buf2, 0, res);
             length -= res;
         }
     }
-
-    /**
-     * Simple command line tool to patch a file.
-     */
-    public static void main(String argv[]) {
-
-        if (argv.length != 3) {
-            System.err.println("usage GDiffPatch source patch output");
-            System.err.println("aborting..");
-            return;
-        }
-        try {
-            File sourceFile = new File(argv[0]);
-            File patchFile = new File(argv[1]);
-            File outputFile = new File(argv[2]);
-
-            if (sourceFile.length() > Integer.MAX_VALUE ||
-            patchFile.length() > Integer.MAX_VALUE) {
-                System.err.println("source or patch is too large, max length is " + Integer.MAX_VALUE);
-                System.err.println("aborting..");
-                return;
-            }
-            GDiffPatcher patcher = new GDiffPatcher();
-            patcher.patch(sourceFile, patchFile, outputFile);
-
-            System.out.println("finished patching file");
-
-        } catch (Exception ioe) {                                   //gls031504a
-            System.err.println("error while patching: " + ioe);
-        }
-    }
 }
 

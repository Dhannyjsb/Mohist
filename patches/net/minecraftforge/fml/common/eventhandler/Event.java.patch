--- ../src-base/minecraft/net/minecraftforge/fml/common/eventhandler/Event.java
+++ ../src-work/minecraft/net/minecraftforge/fml/common/eventhandler/Event.java
@@ -19,41 +19,26 @@
 
 package net.minecraftforge.fml.common.eventhandler;
 
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
+import com.google.common.base.Preconditions;
 
+import javax.annotation.Nonnull;
+import javax.annotation.Nullable;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import com.google.common.base.Preconditions;
 
-
 /**
  * Base Event class that all other events are derived from
  */
-public class Event
-{
-    @Retention(value = RUNTIME)
-    @Target(value = TYPE)
-    public @interface HasResult{}
-
-    public enum Result
-    {
-        DENY,
-        DEFAULT,
-        ALLOW
-    }
-
+public class Event {
+    private static ListenerList listeners = new ListenerList();
     private boolean isCanceled = false;
     private Result result = Result.DEFAULT;
-    private static ListenerList listeners = new ListenerList();
     private EventPriority phase = null;
-
-    public Event()
-    {
+    public Event() {
         setup();
     }
 
@@ -64,8 +49,7 @@
      * Note:
      * Events with the Cancelable annotation will have this method automatically added to return true.
      */
-    public boolean isCancelable()
-    {
+    public boolean isCancelable() {
         return false;
     }
 
@@ -73,8 +57,7 @@
      * Determine if this event is canceled and should stop executing.
      * @return The current canceled state
      */
-    public boolean isCanceled()
-    {
+    public boolean isCanceled() {
         return isCanceled;
     }
 
@@ -87,13 +70,11 @@
      *
      * @param cancel The new canceled value
      */
-    public void setCanceled(boolean cancel)
-    {
-        if (!isCancelable())
-        {
+    public void setCanceled(boolean cancel) {
+        if (!isCancelable()) {
             throw new UnsupportedOperationException(
-                "Attempted to call Event#setCanceled() on a non-cancelable event of type: "
-                + this.getClass().getCanonicalName()
+                    "Attempted to call Event#setCanceled() on a non-cancelable event of type: "
+                            + this.getClass().getCanonicalName()
             );
         }
         isCanceled = cancel;
@@ -105,16 +86,14 @@
      * Note:
      * Events with the HasResult annotation will have this method automatically added to return true.
      */
-    public boolean hasResult()
-    {
+    public boolean hasResult() {
         return false;
     }
 
     /**
      * Returns the value set as the result of this event
      */
-    public Result getResult()
-    {
+    public Result getResult() {
         return result;
     }
 
@@ -126,8 +105,7 @@
      *
      * @param value The new result
      */
-    public void setResult(Result value)
-    {
+    public void setResult(Result value) {
         result = value;
     }
 
@@ -135,8 +113,7 @@
      * Called by the base constructor, this is used by ASM generated
      * event classes to setup various functionality such as the listener list.
      */
-    protected void setup()
-    {
+    protected void setup() {
     }
 
     /**
@@ -145,22 +122,30 @@
      *
      * @return Listener List
      */
-    public ListenerList getListenerList()
-    {
+    public ListenerList getListenerList() {
         return listeners;
     }
 
     @Nullable
-    public EventPriority getPhase()
-    {
+    public EventPriority getPhase() {
         return this.phase;
     }
 
-    public void setPhase(@Nonnull EventPriority value)
-    {
+    public void setPhase(@Nonnull EventPriority value) {
         Preconditions.checkNotNull(value, "setPhase argument must not be null");
         int prev = phase == null ? -1 : phase.ordinal();
         Preconditions.checkArgument(prev < value.ordinal(), "Attempted to set event phase to %s when already %s", value, phase);
         phase = value;
     }
+
+    public enum Result {
+        DENY,
+        DEFAULT,
+        ALLOW
+    }
+
+    @Retention(value = RUNTIME)
+    @Target(value = TYPE)
+    public @interface HasResult {
+    }
 }

--- ../src-base/minecraft/net/minecraftforge/fml/common/Loader.java
+++ ../src-work/minecraft/net/minecraftforge/fml/common/Loader.java
@@ -19,23 +19,15 @@
 
 package net.minecraftforge.fml.common;
 
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
-import java.net.MalformedURLException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.Set;
-
+import com.google.common.base.CharMatcher;
+import com.google.common.base.Joiner;
+import com.google.common.base.Splitter;
+import com.google.common.collect.*;
+import com.google.common.collect.Multiset.Entry;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
 import net.minecraft.util.ResourceLocation;
 import net.minecraftforge.common.ForgeVersion;
 import net.minecraftforge.common.capabilities.CapabilityManager;
@@ -51,11 +43,11 @@
 import net.minecraftforge.fml.common.event.FMLInterModComms;
 import net.minecraftforge.fml.common.event.FMLLoadEvent;
 import net.minecraftforge.fml.common.event.FMLModIdMappingEvent;
-import net.minecraftforge.fml.common.registry.*;
+import net.minecraftforge.fml.common.registry.ItemStackHolderInjector;
 import net.minecraftforge.fml.common.toposort.ModSorter;
 import net.minecraftforge.fml.common.toposort.ModSortingException;
-import net.minecraftforge.fml.common.toposort.TopologicalSort;
 import net.minecraftforge.fml.common.toposort.ModSortingException.SortingExceptionData;
+import net.minecraftforge.fml.common.toposort.TopologicalSort;
 import net.minecraftforge.fml.common.versioning.ArtifactVersion;
 import net.minecraftforge.fml.common.versioning.DependencyParser;
 import net.minecraftforge.fml.common.versioning.VersionParser;
@@ -66,37 +58,16 @@
 import net.minecraftforge.fml.relauncher.libraries.Repository;
 import net.minecraftforge.registries.GameData;
 import net.minecraftforge.registries.ObjectHolderRegistry;
-
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.Level;
+import red.mohist.api.ServerAPI;
+import red.mohist.i18n.Message;
 
-import com.google.common.base.CharMatcher;
-import com.google.common.base.Joiner;
-import com.google.common.base.Splitter;
-import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.BiMap;
-import com.google.common.collect.HashBiMap;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultiset;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.LinkedHashMultimap;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
-import com.google.common.collect.Multiset.Entry;
-import com.google.common.collect.Multisets;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.SetMultimap;
-import com.google.common.collect.Sets;
-import com.google.common.collect.TreeMultimap;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-
 import javax.annotation.Nullable;
+import java.io.*;
+import java.net.MalformedURLException;
+import java.nio.charset.StandardCharsets;
+import java.util.*;
 
 /**
  * The loader class performs the actual loading of the mod code from disk.
@@ -130,8 +101,7 @@
  *
  */
 @SuppressWarnings("unused")
-public class Loader
-{
+public class Loader {
     public static final String MC_VERSION = ForgeVersion.mcVersion;
     /**
      * The singleton instance
@@ -146,7 +116,8 @@
     private static String build;
     private static String mccversion;
     private static String mcpversion;
-
+    private static File minecraftDir;
+    private static List<String> injectedContainers;
     /**
      * The class loader we load the mods into.
      */
@@ -171,18 +142,31 @@
     private LoadController modController;
     private MinecraftDummyContainer minecraft;
     private MCPDummyContainer mcp;
-
-    private static File minecraftDir;
-    private static List<String> injectedContainers;
     private ImmutableMap<String, String> fmlBrandingProperties;
     private File forcedModFile;
     private ModDiscoverer discoverer;
     private ProgressBar progressBar;
+    private ListMultimap<String, ArtifactVersion> injectedBefore = ArrayListMultimap.create();
+    private ListMultimap<String, ArtifactVersion> injectedAfter = ArrayListMultimap.create();
 
-    public static Loader instance()
-    {
-        if (instance == null)
-        {
+    private Loader() {
+        modClassLoader = new ModClassLoader(getClass().getClassLoader());
+        if (mccversion != null && !mccversion.equals(MC_VERSION)) {
+            FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_1, new Object[]{mccversion, MC_VERSION}));
+            throw new LoaderException(Message.getFormatString(Message.forge_loader_2, new Object[]{mccversion, MC_VERSION}));
+        }
+
+        minecraft = new MinecraftDummyContainer(MC_VERSION);
+        InputStream mcpModInputStream = getClass().getResourceAsStream("/mcpmod.info");
+        try {
+            mcp = new MCPDummyContainer(MetadataCollection.from(mcpModInputStream, "MCP").getMetadataForId("mcp", null));
+        } finally {
+            IOUtils.closeQuietly(mcpModInputStream);
+        }
+    }
+
+    public static Loader instance() {
+        if (instance == null) {
             instance = new Loader();
         }
 
@@ -190,8 +174,7 @@
     }
 
     @SuppressWarnings("unchecked")
-    public static void injectData(Object... data)
-    {
+    public static void injectData(Object... data) {
         major = (String) data[0];
         minor = (String) data[1];
         rev = (String) data[2];
@@ -199,28 +182,17 @@
         mccversion = (String) data[4];
         mcpversion = (String) data[5];
         minecraftDir = (File) data[6];
-        injectedContainers = (List<String>)data[7];
+        injectedContainers = (List<String>) data[7];
     }
 
-    private Loader()
-    {
-        modClassLoader = new ModClassLoader(getClass().getClassLoader());
-        if (mccversion !=null && !mccversion.equals(MC_VERSION))
-        {
-            FMLLog.log.fatal("This version of FML is built for Minecraft {}, we have detected Minecraft {} in your minecraft jar file", mccversion, MC_VERSION);
-            throw new LoaderException(String.format("This version of FML is built for Minecraft %s, we have detected Minecraft %s in your minecraft jar file", mccversion, MC_VERSION));
-        }
-
-        minecraft = new MinecraftDummyContainer(MC_VERSION);
-        InputStream mcpModInputStream = getClass().getResourceAsStream("/mcpmod.info");
-        try
-        {
-            mcp = new MCPDummyContainer(MetadataCollection.from(mcpModInputStream, "MCP").getMetadataForId("mcp", null));
-        }
-        finally
-        {
-            IOUtils.closeQuietly(mcpModInputStream);
-        }
+    /**
+     * Query if we know of a mod named modname
+     *
+     * @param modname
+     * @return If the mod is loaded
+     */
+    public static boolean isModLoaded(String modname) {
+        return instance().namedMods.containsKey(modname) && instance().modController.getModState(instance.namedMods.get(modname)) != ModState.DISABLED;
     }
 
     /**
@@ -228,25 +200,20 @@
      * containers. The sorting is performed using a {@link TopologicalSort}
      * based on the pre- and post- dependency information provided by the mods.
      */
-    private void sortModList()
-    {
-        FMLLog.log.trace("Verifying mod requirements are satisfied");
+    private void sortModList() {
+        FMLLog.log.trace(Message.getString(Message.forge_loader_3));
         List<WrongMinecraftVersionException> wrongMinecraftExceptions = new ArrayList<>();
         List<MissingModsException> missingModsExceptions = new ArrayList<>();
-        try
-        {
+        try {
             BiMap<String, ArtifactVersion> modVersions = HashBiMap.create();
-            for (ModContainer mod : Iterables.concat(getActiveModList(), ModAPIManager.INSTANCE.getAPIList()))
-            {
+            for (ModContainer mod : Iterables.concat(getActiveModList(), ModAPIManager.INSTANCE.getAPIList())) {
                 modVersions.put(mod.getModId(), mod.getProcessedVersion());
             }
 
             ArrayListMultimap<String, String> reqList = ArrayListMultimap.create();
-            for (ModContainer mod : getActiveModList())
-            {
-                if (!mod.acceptableMinecraftVersionRange().containsVersion(minecraft.getProcessedVersion()))
-                {
-                    FMLLog.log.fatal("The mod {} does not wish to run in Minecraft version {}. You will have to remove it to play.", mod.getModId(), getMCVersionString());
+            for (ModContainer mod : getActiveModList()) {
+                if (!mod.acceptableMinecraftVersionRange().containsVersion(minecraft.getProcessedVersion())) {
+                    FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_4, new Object[]{mod.getModId(), getMCVersionString()}));
                     WrongMinecraftVersionException ret = new WrongMinecraftVersionException(mod, getMCVersionString());
                     FMLLog.log.fatal(ret.getMessage());
                     wrongMinecraftExceptions.add(ret);
@@ -262,48 +229,36 @@
                 allDeps.addAll(mod.getRequirements());
 
                 MissingModsException missingModsException = new MissingModsException(mod.getModId(), mod.getName());
-                for (ArtifactVersion acceptedVersion : allDeps)
-                {
+                for (ArtifactVersion acceptedVersion : allDeps) {
                     boolean required = mod.getRequirements().contains(acceptedVersion);
-                    if (required || modVersions.containsKey(acceptedVersion.getLabel()))
-                    {
+                    if (required || modVersions.containsKey(acceptedVersion.getLabel())) {
                         ArtifactVersion currentVersion = modVersions.get(acceptedVersion.getLabel());
-                        if (currentVersion == null || !acceptedVersion.containsVersion(currentVersion))
-                        {
+                        if (currentVersion == null || !acceptedVersion.containsVersion(currentVersion)) {
                             missingModsException.addMissingMod(acceptedVersion, currentVersion, required);
                         }
                     }
                 }
-                if (!missingModsException.getMissingModInfos().isEmpty())
-                {
+                if (!missingModsException.getMissingModInfos().isEmpty()) {
                     FMLLog.log.fatal(missingModsException.toString());
                     missingModsExceptions.add(missingModsException);
                 }
             }
 
-            if (wrongMinecraftExceptions.isEmpty() && missingModsExceptions.isEmpty())
-            {
-                FMLLog.log.trace("All mod requirements are satisfied");
-            }
-            else if (missingModsExceptions.size()==1 && wrongMinecraftExceptions.isEmpty())
-            {
+            if (wrongMinecraftExceptions.isEmpty() && missingModsExceptions.isEmpty()) {
+                FMLLog.log.trace(Message.getString(Message.forge_loader_5));
+            } else if (missingModsExceptions.size() == 1 && wrongMinecraftExceptions.isEmpty()) {
                 throw missingModsExceptions.get(0);
-            }
-            else if (wrongMinecraftExceptions.size()==1 && missingModsExceptions.isEmpty())
-            {
+            } else if (wrongMinecraftExceptions.size() == 1 && missingModsExceptions.isEmpty()) {
                 throw wrongMinecraftExceptions.get(0);
-            }
-            else
-            {
+            } else {
                 throw new MultipleModsErrored(wrongMinecraftExceptions, missingModsExceptions);
             }
 
             reverseDependencies = Multimaps.invertFrom(reqList, ArrayListMultimap.create());
             ModSorter sorter = new ModSorter(getActiveModList(), namedMods);
 
-            try
-            {
-                FMLLog.log.trace("Sorting mods into an ordered list");
+            try {
+                FMLLog.log.trace(Message.getString(Message.forge_loader_6));
                 List<ModContainer> sortedMods = sorter.sort();
                 // Reset active list to the sorted list
                 modController.getActiveModList().clear();
@@ -312,37 +267,29 @@
                 mods.removeAll(sortedMods);
                 sortedMods.addAll(mods);
                 mods = sortedMods;
-                FMLLog.log.trace("Mod sorting completed successfully");
-            }
-            catch (ModSortingException sortException)
-            {
-                FMLLog.log.fatal("A dependency cycle was detected in the input mod set so an ordering cannot be determined");
+                FMLLog.log.trace(Message.getString(Message.forge_loader_7));
+            } catch (ModSortingException sortException) {
+                FMLLog.log.fatal(Message.getString(Message.forge_loader_8));
                 SortingExceptionData<ModContainer> exceptionData = sortException.getExceptionData();
-                FMLLog.log.fatal("The first mod in the cycle is {}", exceptionData.getFirstBadNode());
-                FMLLog.log.fatal("The mod cycle involves");
-                for (ModContainer mc : exceptionData.getVisitedNodes())
-                {
-                    FMLLog.log.fatal("{} : before: {}, after: {}", mc.toString(), mc.getDependants(), mc.getDependencies());
+                FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_9, new Object[]{exceptionData.getFirstBadNode()}));
+                FMLLog.log.fatal(Message.getString(Message.forge_loader_10));
+                for (ModContainer mc : exceptionData.getVisitedNodes()) {
+                    FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_11, new Object[]{mc.toString(), mc.getDependants(), mc.getDependencies()}));
                 }
-                FMLLog.log.error("The full error", sortException);
+                FMLLog.log.error(Message.getFormatString(Message.forge_loader_12, new Object[]{sortException}));
                 throw sortException;
             }
-        }
-        finally
-        {
-            FMLLog.log.debug("Mod sorting data");
+        } finally {
+            FMLLog.log.debug(Message.getString(Message.forge_loader_13));
             int unprintedMods = mods.size();
-            for (ModContainer mod : getActiveModList())
-            {
-                if (!mod.isImmutable())
-                {
-                    FMLLog.log.debug("\t{}({}:{}): {} ({})", mod.getModId(), mod.getName(), mod.getVersion(), mod.getSource().getName(), mod.getSortingRules());
+            for (ModContainer mod : getActiveModList()) {
+                if (!mod.isImmutable()) {
+                    FMLLog.log.debug("\t" + Message.getFormatString(Message.forge_loader_14, new Object[]{mod.getModId(), mod.getName(), mod.getVersion(), mod.getSource().getName(), mod.getSortingRules()}));
                     unprintedMods--;
                 }
             }
-            if (unprintedMods == mods.size())
-            {
-                FMLLog.log.debug("No user mods found to sort");
+            if (unprintedMods == mods.size()) {
+                FMLLog.log.debug(Message.getString(Message.forge_loader_15));
             }
         }
 
@@ -362,44 +309,37 @@
      * Finally, if they are successfully loaded as classes, they are then added
      * to the available mod list.
      */
-    private ModDiscoverer identifyMods(List<String> additionalContainers)
-    {
+    private ModDiscoverer identifyMods(List<String> additionalContainers) {
         injectedContainers.addAll(additionalContainers);
-        FMLLog.log.debug("Building injected Mod Containers {}", injectedContainers);
+        FMLLog.log.debug(Message.getFormatString(Message.forge_loader_16, new Object[]{injectedContainers}));
         mods.add(minecraft);
         // Add in the MCP mod container
-        mods.add(new InjectedModContainer(mcp,new File("minecraft.jar")));
-        for (String cont : injectedContainers)
-        {
+        mods.add(new InjectedModContainer(mcp, new File("minecraft.jar")));
+        for (String cont : injectedContainers) {
             ModContainer mc;
-            try
-            {
-                mc = (ModContainer) Class.forName(cont,true,modClassLoader).newInstance();
-            }
-            catch (Exception e)
-            {
-                FMLLog.log.error("A problem occurred instantiating the injected mod container {}", cont, e);
+            try {
+                mc = (ModContainer) Class.forName(cont, true, modClassLoader).newInstance();
+            } catch (Exception e) {
+                FMLLog.log.error(Message.getFormatString(Message.forge_loader_17, new Object[]{cont, e}));
                 throw new LoaderException(e);
             }
-            mods.add(new InjectedModContainer(mc,mc.getSource()));
+            mods.add(new InjectedModContainer(mc, mc.getSource()));
         }
         ModDiscoverer discoverer = new ModDiscoverer();
 
         //if (!FMLForgePlugin.RUNTIME_DEOBF) //Only descover mods in the classpath if we're in the dev env.
         {                                  //TODO: Move this to GradleStart? And add a specific mod canidate for Forge itself.
-            FMLLog.log.debug("Attempting to load mods contained in the minecraft jar file and associated classes");
+            FMLLog.log.debug(Message.getString(Message.forge_loader_18));
             discoverer.findClasspathMods(modClassLoader);
-            FMLLog.log.debug("Minecraft jar mods loaded successfully");
+            FMLLog.log.debug(Message.getString(Message.forge_loader_19));
         }
 
         List<Artifact> maven_canidates = LibraryManager.flattenLists(minecraftDir);
         List<File> file_canidates = LibraryManager.gatherLegacyCanidates(minecraftDir);
 
-        for (Artifact artifact : maven_canidates)
-        {
+        for (Artifact artifact : maven_canidates) {
             artifact = Repository.resolveAll(artifact);
-            if (artifact != null)
-            {
+            if (artifact != null) {
                 File target = artifact.getFile();
                 if (!file_canidates.contains(target))
                     file_canidates.add(target);
@@ -408,16 +348,12 @@
         //Do we want to sort the full list after resolving artifacts?
         //TODO: Add dependency gathering?
 
-        for (File mod : file_canidates)
-        {
+        for (File mod : file_canidates) {
             // skip loaded coremods
-            if (CoreModManager.getIgnoredMods().contains(mod.getName()))
-            {
-                FMLLog.log.trace("Skipping already parsed coremod or tweaker {}", mod.getName());
-            }
-            else
-            {
-                FMLLog.log.debug("Found a candidate zip or jar file {}", mod.getName());
+            if (CoreModManager.getIgnoredMods().contains(mod.getName())) {
+                FMLLog.log.trace(Message.getFormatString(Message.forge_loader_20, new Object[]{mod.getName()}));
+            } else {
+                FMLLog.log.debug(Message.getFormatString(Message.forge_loader_21, new Object[]{mod.getName()}));
                 discoverer.addCandidate(new ModCandidate(mod, mod, ContainerType.JAR));
             }
         }
@@ -425,42 +361,27 @@
         mods.addAll(discoverer.identifyMods());
         identifyDuplicates(mods);
         namedMods = Maps.uniqueIndex(mods, ModContainer::getModId);
-        FMLLog.log.info("Forge Mod Loader has identified {} mod{} to load", mods.size(), mods.size() != 1 ? "s" : "");
+        FMLLog.log.info(Message.getFormatString(Message.forge_loader_22, new Object[]{mods.size(), mods.size() != 1 ? "s" : ""}));
         return discoverer;
     }
 
-    private class ModIdComparator implements Comparator<ModContainer>
-    {
-        @Override
-        public int compare(ModContainer o1, ModContainer o2)
-        {
-            return o1.getModId().compareTo(o2.getModId());
-        }
-    }
-
-    private void identifyDuplicates(List<ModContainer> mods)
-    {
+    private void identifyDuplicates(List<ModContainer> mods) {
         TreeMultimap<ModContainer, File> dupsearch = TreeMultimap.create(new ModIdComparator(), Ordering.arbitrary());
-        for (ModContainer mc : mods)
-        {
-            if (mc.getSource() != null)
-            {
+        for (ModContainer mc : mods) {
+            if (mc.getSource() != null) {
                 dupsearch.put(mc, mc.getSource());
             }
         }
 
         ImmutableMultiset<ModContainer> duplist = Multisets.copyHighestCountFirst(dupsearch.keys());
         SetMultimap<ModContainer, File> dupes = LinkedHashMultimap.create();
-        for (Entry<ModContainer> e : duplist.entrySet())
-        {
-            if (e.getCount() > 1)
-            {
-                FMLLog.log.fatal("Found a duplicate mod {} at {}", e.getElement().getModId(), dupsearch.get(e.getElement()));
-                dupes.putAll(e.getElement(),dupsearch.get(e.getElement()));
+        for (Entry<ModContainer> e : duplist.entrySet()) {
+            if (e.getCount() > 1) {
+                FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_23, new Object[]{e.getElement().getModId(), dupsearch.get(e.getElement())}));
+                dupes.putAll(e.getElement(), dupsearch.get(e.getElement()));
             }
         }
-        if (!dupes.isEmpty())
-        {
+        if (!dupes.isEmpty()) {
             throw new DuplicateModsFoundException(dupes);
         }
     }
@@ -468,68 +389,56 @@
     /**
      *
      */
-    private void initializeLoader()
-    {
+    private void initializeLoader() {
         File modsDir = new File(minecraftDir, "mods");
         File configDir = new File(minecraftDir, "config");
         String canonicalModsPath;
         String canonicalConfigPath;
 
-        try
-        {
+        try {
             canonicalModsPath = modsDir.getCanonicalPath();
             canonicalConfigPath = configDir.getCanonicalPath();
             canonicalConfigDir = configDir.getCanonicalFile();
             canonicalModsDir = modsDir.getCanonicalFile();
-        }
-        catch (IOException ioe)
-        {
-            FMLLog.log.error("Failed to resolve loader directories: mods : {} ; config {}", canonicalModsDir.getAbsolutePath(),
-                            configDir.getAbsolutePath(), ioe);
+        } catch (IOException ioe) {
+            FMLLog.log.error(Message.getFormatString(Message.forge_loader_24, new Object[]{canonicalModsDir.getAbsolutePath(), configDir.getAbsolutePath(), ioe}));
             throw new LoaderException(ioe);
         }
 
-        if (!canonicalModsDir.exists())
-        {
-            FMLLog.log.info("No mod directory found, creating one: {}", canonicalModsPath);
+        if (!canonicalModsDir.exists()) {
+            FMLLog.log.info(Message.getFormatString(Message.forge_loader_25, new Object[]{canonicalModsPath}));
             boolean dirMade = canonicalModsDir.mkdir();
-            if (!dirMade)
-            {
-                FMLLog.log.fatal("Unable to create the mod directory {}", canonicalModsPath);
-                throw new LoaderException(String.format("Unable to create the mod directory %s", canonicalModsPath));
+            if (!dirMade) {
+                FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_26, new Object[]{canonicalModsPath}));
+                throw new LoaderException(Message.getFormatString(Message.forge_loader_27, new Object[]{canonicalModsPath}));
             }
-            FMLLog.log.info("Mod directory created successfully");
+            FMLLog.log.info(Message.getString(Message.forge_loader_28));
         }
 
-        if (!canonicalConfigDir.exists())
-        {
-            FMLLog.log.debug("No config directory found, creating one: {}", canonicalConfigPath);
+        if (!canonicalConfigDir.exists()) {
+            FMLLog.log.debug(Message.getFormatString(Message.forge_loader_29, new Object[]{canonicalConfigPath}));
             boolean dirMade = canonicalConfigDir.mkdir();
-            if (!dirMade)
-            {
-                FMLLog.log.fatal("Unable to create the config directory {}", canonicalConfigPath);
+            if (!dirMade) {
+                FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_30, new Object[]{canonicalConfigPath}));
                 throw new LoaderException();
             }
-            FMLLog.log.info("Config directory created successfully");
+            FMLLog.log.info(Message.getString(Message.forge_loader_31));
         }
 
-        if (!canonicalModsDir.isDirectory())
-        {
-            FMLLog.log.fatal("Attempting to load mods from {}, which is not a directory", canonicalModsPath);
+        if (!canonicalModsDir.isDirectory()) {
+            FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_32, new Object[]{canonicalModsPath}));
             throw new LoaderException();
         }
 
-        if (!configDir.isDirectory())
-        {
-            FMLLog.log.fatal("Attempting to load configuration from {}, which is not a directory", canonicalConfigPath);
+        if (!configDir.isDirectory()) {
+            FMLLog.log.fatal(Message.getFormatString(Message.forge_loader_33, new Object[]{canonicalConfigPath}));
             throw new LoaderException();
         }
 
         readInjectedDependencies();
     }
 
-    public List<ModContainer> getModList()
-    {
+    public List<ModContainer> getModList() {
         return instance().mods != null ? ImmutableList.copyOf(instance().mods) : ImmutableList.<ModContainer>of();
     }
 
@@ -537,8 +446,7 @@
      * Used to setup a testharness with a single dummy mod instance for use with various testing hooks
      * @param containers A list of dummy containers that will be returned as "active" for all queries
      */
-    public void setupTestHarness(ModContainer... containers)
-    {
+    public void setupTestHarness(ModContainer... containers) {
         modController = new LoadController(this);
         mods = Lists.newArrayList(containers);
         namedMods = Maps.uniqueIndex(mods, ModContainer::getModId);
@@ -554,8 +462,7 @@
      * the mod list is frozen completely and is consider immutable from then on.
      * @param injectedModContainers containers to inject
      */
-    public void loadMods(List<String> injectedModContainers)
-    {
+    public void loadMods(List<String> injectedModContainers) {
         progressBar = ProgressManager.push("Loading", 7);
         progressBar.step("Constructing Mods");
         initializeLoader();
@@ -571,19 +478,14 @@
         ModAPIManager.INSTANCE.cleanupAPIContainers(modController.getActiveModList());
         ModAPIManager.INSTANCE.cleanupAPIContainers(mods);
         mods = ImmutableList.copyOf(mods);
-        for (File nonMod : discoverer.getNonModLibs())
-        {
-            if (nonMod.isFile())
-            {
-                FMLLog.log.info("FML has found a non-mod file {} in your mods directory. It will now be injected into your classpath. This could severe stability issues, it should be removed if possible.", nonMod.getName());
-                try
-                {
+        for (File nonMod : discoverer.getNonModLibs()) {
+            if (nonMod.isFile()) {
+                FMLLog.log.info(Message.getFormatString(Message.forge_loader_34, new Object[]{nonMod.getName()}));
+                try {
                     modClassLoader.addFile(nonMod);
+                } catch (MalformedURLException e) {
+                    FMLLog.log.error(Message.getFormatString(Message.forge_loader_35, new Object[]{nonMod.getName(), e}));
                 }
-                catch (MalformedURLException e)
-                {
-                    FMLLog.log.error("Encountered a weird problem with non-mod file injection : {}", nonMod.getName(), e);
-                }
             }
         }
 
@@ -592,32 +494,27 @@
         modController.transition(LoaderState.CONSTRUCTING, false);
         modController.distributeStateMessage(LoaderState.CONSTRUCTING, modClassLoader, discoverer.getASMTable(), reverseDependencies);
 
-        FMLLog.log.debug("Mod signature data");
-        FMLLog.log.debug(" \tValid Signatures:");
-        for (ModContainer mod : getActiveModList())
-        {
+        FMLLog.log.debug(Message.getString(Message.forge_loader_36));
+        FMLLog.log.debug(" \t" + Message.getString(Message.forge_loader_37));
+        for (ModContainer mod : getActiveModList()) {
             if (mod.getSigningCertificate() != null)
                 FMLLog.log.debug("\t\t({}) {}\t({}\t{})\t{}", CertificateHelper.getFingerprint(mod.getSigningCertificate()), mod.getModId(), mod.getName(), mod.getVersion(), mod.getSource().getName());
         }
-        FMLLog.log.debug(" \tMissing Signatures:");
-        for (ModContainer mod : getActiveModList())
-        {
+        FMLLog.log.debug(" \t " + Message.getString(Message.forge_loader_38));
+        for (ModContainer mod : getActiveModList()) {
             if (mod.getSigningCertificate() == null)
                 FMLLog.log.debug("\t\t{}\t({}\t{})\t{}", mod.getModId(), mod.getName(), mod.getVersion(), mod.getSource().getName());
         }
-        if (getActiveModList().isEmpty())
-        {
-            FMLLog.log.debug("No user mod signature data found");
+        if (getActiveModList().isEmpty()) {
+            FMLLog.log.debug(Message.getString(Message.forge_loader_39));
         }
         progressBar.step("Initializing mods Phase 1");
         modController.transition(LoaderState.PREINITIALIZATION, false);
     }
 
-    public void preinitializeMods()
-    {
-        if (!modController.isInState(LoaderState.PREINITIALIZATION))
-        {
-            FMLLog.log.warn("There were errors previously. Not beginning mod initialization phase");
+    public void preinitializeMods() {
+        if (!modController.isInState(LoaderState.PREINITIALIZATION)) {
+            FMLLog.log.warn(Message.getString(Message.forge_loader_40));
             return;
         }
         GameData.fireCreateRegistryEvents();
@@ -633,88 +530,64 @@
         progressBar.step("Initializing Minecraft Engine");
     }
 
-    private void disableRequestedMods()
-    {
+    private void disableRequestedMods() {
         String forcedModList = System.getProperty("fml.modStates", "");
-        FMLLog.log.trace("Received a system property request \'{}\'",forcedModList);
+        FMLLog.log.trace(Message.getFormatString(Message.forge_loader_41, new Object[]{forcedModList}));
         Map<String, String> sysPropertyStateList = Splitter.on(CharMatcher.anyOf(";:"))
                 .omitEmptyStrings().trimResults().withKeyValueSeparator("=")
                 .split(forcedModList);
-        FMLLog.log.trace("System property request managing the state of {} mods", sysPropertyStateList.size());
+        FMLLog.log.trace(Message.getFormatString(Message.forge_loader_42, new Object[]{sysPropertyStateList.size()}));
         Map<String, String> modStates = Maps.newHashMap();
 
         forcedModFile = new File(canonicalConfigDir, "fmlModState.properties");
         Properties forcedModListProperties = new Properties();
-        if (forcedModFile.exists() && forcedModFile.isFile())
-        {
-            FMLLog.log.trace("Found a mod state file {}", forcedModFile.getName());
-            try
-            {
+        if (forcedModFile.exists() && forcedModFile.isFile()) {
+            FMLLog.log.trace(Message.getFormatString(Message.forge_loader_43, new Object[]{forcedModFile.getName()}));
+            try {
                 forcedModListProperties.load(new InputStreamReader(new FileInputStream(forcedModFile), StandardCharsets.UTF_8));
-                FMLLog.log.trace("Loaded states for {} mods from file", forcedModListProperties.size());
+                FMLLog.log.trace(Message.getFormatString(Message.forge_loader_44, new Object[]{forcedModListProperties.size()}));
+            } catch (Exception e) {
+                FMLLog.log.info(Message.getString(Message.forge_loader_45), e);
             }
-            catch (Exception e)
-            {
-                FMLLog.log.info("An error occurred reading the fmlModState.properties file", e);
-            }
         }
         modStates.putAll(Maps.fromProperties(forcedModListProperties));
         modStates.putAll(sysPropertyStateList);
-        FMLLog.log.debug("After merging, found state information for {} mods", modStates.size());
+        FMLLog.log.debug(Message.getFormatString(Message.forge_loader_46, new Object[]{modStates.size()}));
 
         Map<String, Boolean> isEnabled = Maps.transformValues(modStates, Boolean::parseBoolean);
 
-        for (Map.Entry<String, Boolean> entry : isEnabled.entrySet())
-        {
-            if (namedMods.containsKey(entry.getKey()))
-            {
-                FMLLog.log.info("Setting mod {} to enabled state {}", entry.getKey(), entry.getValue());
+        for (Map.Entry<String, Boolean> entry : isEnabled.entrySet()) {
+            if (namedMods.containsKey(entry.getKey())) {
+                FMLLog.log.info(Message.getFormatString(Message.forge_loader_47, new Object[]{entry.getKey(), entry.getValue()}));
                 namedMods.get(entry.getKey()).setEnabledState(entry.getValue());
             }
         }
     }
 
-    /**
-     * Query if we know of a mod named modname
-     *
-     * @param modname
-     * @return If the mod is loaded
-     */
-    public static boolean isModLoaded(String modname)
-    {
-        return instance().namedMods.containsKey(modname) && instance().modController.getModState(instance.namedMods.get(modname))!=ModState.DISABLED;
-    }
-
-    public File getConfigDir()
-    {
+    public File getConfigDir() {
         return canonicalConfigDir;
     }
 
-    public String getCrashInformation()
-    {
+    public String getCrashInformation() {
         // Handle being called before we've begun setup
-        if (modController == null)
-        {
+        if (modController == null) {
             return "";
         }
         StringBuilder ret = new StringBuilder();
         List<String> branding = FMLCommonHandler.instance().getBrandings(false);
 
         Joiner.on(' ').skipNulls().appendTo(ret, branding);
-        if (modController != null)
-        {
+        if (modController != null) {
             modController.printModStates(ret);
         }
         return ret.toString();
     }
 
-    public String getFMLVersionString()
-    {
+    public String getFMLVersionString() {
         return "8.0.99.99";
     }
 
-    public ModClassLoader getModClassLoader()
-    {
+    public ModClassLoader getModClassLoader() {
         return modClassLoader;
     }
 
@@ -722,8 +595,7 @@
      * @deprecated use {@link DependencyParser#parseDependencies(String)}
      */
     @Deprecated // TODO: remove in 1.13
-    public void computeDependencies(String dependencyString, Set<ArtifactVersion> requirements, List<ArtifactVersion> dependencies, List<ArtifactVersion> dependants)
-    {
+    public void computeDependencies(String dependencyString, Set<ArtifactVersion> requirements, List<ArtifactVersion> dependencies, List<ArtifactVersion> dependants) {
         DependencyParser dependencyParser = new DependencyParser("unknown", FMLCommonHandler.instance().getSide());
         DependencyParser.DependencyInfo info = dependencyParser.parseDependencies(dependencyString);
         requirements.addAll(info.requirements);
@@ -731,13 +603,11 @@
         dependants.addAll(info.dependants);
     }
 
-    public Map<String,ModContainer> getIndexedModList()
-    {
+    public Map<String, ModContainer> getIndexedModList() {
         return namedMods != null ? ImmutableMap.copyOf(namedMods) : ImmutableMap.of();
     }
 
-    public void initializeMods()
-    {
+    public void initializeMods() {
         progressBar.step("Initializing mods Phase 2");
         CraftingHelper.loadRecipes(false);
         // Mod controller should be in the initialization state here
@@ -751,122 +621,100 @@
         modController.transition(LoaderState.AVAILABLE, false);
         modController.distributeStateMessage(LoaderState.AVAILABLE);
         GameData.freezeData();
-        FMLLog.log.info("Forge Mod Loader has successfully loaded {} mod{}", mods.size(), mods.size() == 1 ? "" : "s");
+        ServerAPI.mods.put("mods", mods.size());
+        FMLLog.log.info(Message.getFormatString(Message.forge_loader_48, new Object[]{mods.size(), mods.size() == 1 ? "" : "s"}));
         progressBar.step("Completing Minecraft initialization");
     }
 
-    public ICrashCallable getCallableCrashInformation()
-    {
+    public ICrashCallable getCallableCrashInformation() {
         return new ICrashCallable() {
             @Override
-            public String call() throws Exception
-            {
+            public String call() throws Exception {
                 return getCrashInformation();
             }
 
             @Override
-            public String getLabel()
-            {
+            public String getLabel() {
                 return "FML";
             }
         };
     }
 
-    public List<ModContainer> getActiveModList()
-    {
+    public List<ModContainer> getActiveModList() {
         return modController != null ? modController.getActiveModList() : ImmutableList.<ModContainer>of();
     }
 
-    public ModState getModState(ModContainer selectedMod)
-    {
+    public ModState getModState(ModContainer selectedMod) {
         return modController.getModState(selectedMod);
     }
 
-    public String getMCVersionString()
-    {
+    public String getMCVersionString() {
         return "Minecraft " + mccversion;
     }
 
-    public boolean serverStarting(Object server)
-    {
+    public boolean serverStarting(Object server) {
         modController.distributeStateMessage(LoaderState.SERVER_STARTING, server);
         modController.transition(LoaderState.SERVER_STARTING, false);
         return true;
     }
 
-    public void serverStarted()
-    {
+    public void serverStarted() {
         modController.distributeStateMessage(LoaderState.SERVER_STARTED);
         modController.transition(LoaderState.SERVER_STARTED, false);
     }
 
-    public void serverStopping()
-    {
+    public void serverStopping() {
         modController.distributeStateMessage(LoaderState.SERVER_STOPPING);
         modController.transition(LoaderState.SERVER_STOPPING, false);
     }
 
-    public BiMap<ModContainer, Object> getModObjectList()
-    {
+    public BiMap<ModContainer, Object> getModObjectList() {
         return modController.getModObjectList();
     }
 
-    public BiMap<Object, ModContainer> getReversedModObjectList()
-    {
+    public BiMap<Object, ModContainer> getReversedModObjectList() {
         return getModObjectList().inverse();
     }
 
     @Nullable
-    public ModContainer activeModContainer()
-    {
+    public ModContainer activeModContainer() {
         return modController != null ? modController.activeContainer() : null;
     }
 
-    public boolean isInState(LoaderState state)
-    {
+    public boolean isInState(LoaderState state) {
         return modController.isInState(state);
     }
 
-    public MinecraftDummyContainer getMinecraftModContainer()
-    {
+    public MinecraftDummyContainer getMinecraftModContainer() {
         return minecraft;
     }
 
-    public boolean hasReachedState(LoaderState state)
-    {
+    public boolean hasReachedState(LoaderState state) {
         return modController != null ? modController.hasReachedState(state) : false;
     }
 
-    public String getMCPVersionString()
-    {
+    public String getMCPVersionString() {
         return String.format("MCP %s", mcpversion);
     }
 
-    public void serverStopped()
-    {
+    public void serverStopped() {
         modController.distributeStateMessage(LoaderState.SERVER_STOPPED);
         modController.transition(LoaderState.SERVER_STOPPED, true);
         modController.transition(LoaderState.AVAILABLE, true);
     }
 
-    public boolean serverAboutToStart(Object server)
-    {
+    public boolean serverAboutToStart(Object server) {
         modController.distributeStateMessage(LoaderState.SERVER_ABOUT_TO_START, server);
         modController.transition(LoaderState.SERVER_ABOUT_TO_START, false);
         return true;
     }
 
-    public Map<String,String> getFMLBrandingProperties()
-    {
-        if (fmlBrandingProperties == null)
-        {
+    public Map<String, String> getFMLBrandingProperties() {
+        if (fmlBrandingProperties == null) {
             Properties loaded = new Properties();
-            try
-            {
+            try {
                 loaded.load(getClass().getClassLoader().getResourceAsStream("fmlbranding.properties"));
-            }
-            catch (Exception e)
-            {
+            } catch (Exception e) {
                 // File not found - ignore
             }
             fmlBrandingProperties = Maps.fromProperties(loaded);
@@ -874,106 +722,85 @@
         return fmlBrandingProperties;
     }
 
-
-    public Map<String,String> getCustomModProperties(String modId)
-    {
+    public Map<String, String> getCustomModProperties(String modId) {
         return getIndexedModList().get(modId).getCustomModProperties();
     }
 
-    boolean checkRemoteModList(Map<String, String> modList, Side side)
-    {
+    boolean checkRemoteModList(Map<String, String> modList, Side side) {
         Set<String> remoteModIds = modList.keySet();
         Set<String> localModIds = namedMods.keySet();
 
         Set<String> difference = Sets.newLinkedHashSet(Sets.difference(localModIds, remoteModIds));
-        for (Iterator<String> iterator = difference.iterator(); iterator.hasNext();)
-        {
+        for (Iterator<String> iterator = difference.iterator(); iterator.hasNext(); ) {
             String missingRemotely = iterator.next();
             ModState modState = modController.getModState(namedMods.get(missingRemotely));
-            if (modState == ModState.DISABLED)
-            {
+            if (modState == ModState.DISABLED) {
                 iterator.remove();
             }
         }
 
-        if (difference.size() > 0)
-            FMLLog.log.info("Attempting connection with missing mods {} at {}", difference, side);
+        if (difference.size() > 0) {
+            ServerAPI.modlists.addAll(difference);
+            FMLLog.log.info(Message.getFormatString(Message.forge_loader_49, new Object[]{difference, side}));
+        }
         return true;
     }
 
-    public void fireRemapEvent(Map<ResourceLocation, Map<ResourceLocation, Integer[]>> remaps, boolean isFreezing)
-    {
-        if (modController!=null)
-        {
+    public void fireRemapEvent(Map<ResourceLocation, Map<ResourceLocation, Integer[]>> remaps, boolean isFreezing) {
+        if (modController != null) {
             modController.propogateStateMessage(new FMLModIdMappingEvent(remaps, isFreezing));
         }
     }
 
-    public void runtimeDisableMod(String modId)
-    {
+    public void runtimeDisableMod(String modId) {
         ModContainer mc = namedMods.get(modId);
         Disableable disableable = mc.canBeDisabled();
-        if (disableable == Disableable.NEVER)
-        {
-            FMLLog.log.info("Cannot disable mod {} - it is never allowed to be disabled", modId);
+        if (disableable == Disableable.NEVER) {
+            FMLLog.log.info(Message.getFormatString(Message.forge_loader_50, new Object[]{modId}));
             return;
         }
-        if (disableable == Disableable.DEPENDENCIES)
-        {
-            FMLLog.log.info("Cannot disable mod {} - there are dependent mods that require its presence", modId);
+        if (disableable == Disableable.DEPENDENCIES) {
+            FMLLog.log.info(Message.getFormatString(Message.forge_loader_51, new Object[]{modId}));
             return;
         }
-        if (disableable == Disableable.YES)
-        {
-            FMLLog.log.info("Runtime disabling mod {}", modId);
+        if (disableable == Disableable.YES) {
+            FMLLog.log.info(Message.getFormatString(Message.forge_loader_52, new Object[]{modId}));
             modController.disableMod(mc);
             List<ModContainer> localmods = Lists.newArrayList(mods);
             localmods.remove(mc);
             mods = ImmutableList.copyOf(localmods);
         }
 
-        try
-        {
+        try {
             Properties props = new Properties();
             props.load(new InputStreamReader(new FileInputStream(forcedModFile), StandardCharsets.UTF_8));
             props.put(modId, "false");
             props.store(new OutputStreamWriter(new FileOutputStream(forcedModFile), StandardCharsets.UTF_8), null);
+        } catch (Exception e) {
+            FMLLog.log.info(Message.getString(Message.forge_loader_53), e);
         }
-        catch (Exception e)
-        {
-            FMLLog.log.info("An error occurred writing the fml mod states file, your disabled change won't persist", e);
-        }
     }
 
-    public void loadingComplete()
-    {
+    public void loadingComplete() {
         ProgressManager.pop(progressBar);
         progressBar = null;
     }
 
-    private ListMultimap<String,ArtifactVersion> injectedBefore = ArrayListMultimap.create();
-    private ListMultimap<String,ArtifactVersion> injectedAfter = ArrayListMultimap.create();
-
-    private void readInjectedDependencies()
-    {
-        File injectedDepFile = new File(getConfigDir(),"injectedDependencies.json");
-        if (!injectedDepFile.exists())
-        {
-            FMLLog.log.debug("File {} not found. No dependencies injected", injectedDepFile.getAbsolutePath());
+    private void readInjectedDependencies() {
+        File injectedDepFile = new File(getConfigDir(), "injectedDependencies.json");
+        if (!injectedDepFile.exists()) {
+            FMLLog.log.debug(Message.getFormatString(Message.forge_loader_54, new Object[]{injectedDepFile.getAbsolutePath()}));
             return;
         }
         JsonParser parser = new JsonParser();
         JsonElement injectedDeps;
-        try
-        {
+        try {
             injectedDeps = parser.parse(new InputStreamReader(new FileInputStream(injectedDepFile), StandardCharsets.UTF_8));
-            for (JsonElement el : injectedDeps.getAsJsonArray())
-            {
+            for (JsonElement el : injectedDeps.getAsJsonArray()) {
                 JsonObject jo = el.getAsJsonObject();
                 String modId = jo.get("modId").getAsString();
                 JsonArray deps = jo.get("deps").getAsJsonArray();
-                for (JsonElement dep : deps)
-                {
+                for (JsonElement dep : deps) {
                     JsonObject depObj = dep.getAsJsonObject();
                     String type = depObj.get("type").getAsString();
                     if (type.equals("before")) {
@@ -981,36 +808,39 @@
                     } else if (type.equals("after")) {
                         injectedAfter.put(modId, VersionParser.parseVersionReference(depObj.get("target").getAsString()));
                     } else {
-                        FMLLog.log.error("Invalid dependency type {}", type);
+                        FMLLog.log.error(Message.getFormatString(Message.forge_loader_55, new Object[]{type}));
                         throw new RuntimeException("Unable to parse type");
                     }
                 }
             }
-        } catch (Exception e)
-        {
-            FMLLog.log.error("Unable to parse {} - skipping", injectedDepFile);
+        } catch (Exception e) {
+            FMLLog.log.error(Message.getFormatString(Message.forge_loader_56, new Object[]{injectedDepFile}));
             FMLLog.log.throwing(Level.ERROR, e);
             return;
         }
-        FMLLog.log.debug("Loaded {} injected dependencies on modIds: {}", injectedBefore.size(), injectedBefore.keySet());
+        FMLLog.log.debug(Message.getFormatString(Message.forge_loader_57, new Object[]{injectedBefore.size(), injectedBefore.keySet()}));
     }
 
-    List<ArtifactVersion> getInjectedBefore(String modId)
-    {
+    List<ArtifactVersion> getInjectedBefore(String modId) {
         return injectedBefore.get(modId);
     }
-    List<ArtifactVersion> getInjectedAfter(String modId)
-    {
+
+    List<ArtifactVersion> getInjectedAfter(String modId) {
         return injectedAfter.get(modId);
     }
 
-    public final LoaderState getLoaderState()
-    {
+    public final LoaderState getLoaderState() {
         return modController != null ? modController.getState() : LoaderState.NOINIT;
     }
 
-    public void setActiveModContainer(@Nullable ModContainer container)
-    {
+    public void setActiveModContainer(@Nullable ModContainer container) {
         this.modController.forceActiveContainer(container);
     }
+
+    private class ModIdComparator implements Comparator<ModContainer> {
+        @Override
+        public int compare(ModContainer o1, ModContainer o2) {
+            return o1.getModId().compareTo(o2.getModId());
+        }
+    }
 }

--- ../src-base/minecraft/net/minecraftforge/fluids/BlockFluidFinite.java
+++ ../src-work/minecraft/net/minecraftforge/fluids/BlockFluidFinite.java
@@ -19,19 +19,18 @@
 
 package net.minecraftforge.fluids;
 
-import java.util.Random;
-
 import net.minecraft.block.material.MapColor;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
+import net.minecraft.util.EnumFacing;
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.EnumFacing;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 import net.minecraftforge.common.util.Constants;
 
 import javax.annotation.Nonnull;
+import java.util.Random;
 
 /**
  * This is a cellular-automata based finite fluid block implementation.
@@ -39,49 +38,40 @@
  * It is highly recommended that you use/extend this class for finite fluid blocks.
  *
  */
-public class BlockFluidFinite extends BlockFluidBase
-{
-    public BlockFluidFinite(Fluid fluid, Material material, MapColor mapColor)
-    {
+public class BlockFluidFinite extends BlockFluidBase {
+    public BlockFluidFinite(Fluid fluid, Material material, MapColor mapColor) {
         super(fluid, material, mapColor);
     }
 
-    public BlockFluidFinite(Fluid fluid, Material material)
-    {
+    public BlockFluidFinite(Fluid fluid, Material material) {
         this(fluid, material, material.getMaterialMapColor());
     }
 
     @Override
-    public int getQuantaValue(IBlockAccess world, BlockPos pos)
-    {
+    public int getQuantaValue(IBlockAccess world, BlockPos pos) {
         IBlockState state = world.getBlockState(pos);
-        if (state.getBlock().isAir(state, world, pos))
-        {
+        if (state.getBlock().isAir(state, world, pos)) {
             return 0;
         }
 
-        if (state.getBlock() != this)
-        {
+        if (state.getBlock() != this) {
             return -1;
         }
         return state.getValue(LEVEL) + 1;
     }
 
     @Override
-    public boolean canCollideCheck(@Nonnull IBlockState state, boolean fullHit)
-    {
+    public boolean canCollideCheck(@Nonnull IBlockState state, boolean fullHit) {
         return fullHit;
     }
 
     @Override
-    public int getMaxRenderHeightMeta()
-    {
+    public int getMaxRenderHeightMeta() {
         return quantaPerBlock - 1;
     }
 
     @Override
-    public void updateTick(@Nonnull World world, @Nonnull BlockPos pos, @Nonnull IBlockState state, @Nonnull Random rand)
-    {
+    public void updateTick(@Nonnull World world, @Nonnull BlockPos pos, @Nonnull IBlockState state, @Nonnull Random rand) {
         boolean changed = false;
         int quantaRemaining = state.getValue(LEVEL) + 1;
 
@@ -89,21 +79,15 @@
         int prevRemaining = quantaRemaining;
         quantaRemaining = tryToFlowVerticallyInto(world, pos, quantaRemaining);
 
-        if (quantaRemaining < 1)
-        {
+        if (quantaRemaining < 1) {
             return;
-        }
-        else if (quantaRemaining != prevRemaining)
-        {
+        } else if (quantaRemaining != prevRemaining) {
             changed = true;
-            if (quantaRemaining == 1)
-            {
+            if (quantaRemaining == 1) {
                 world.setBlockState(pos, state.withProperty(LEVEL, quantaRemaining - 1), Constants.BlockFlags.SEND_TO_CLIENTS);
                 return;
             }
-        }
-        else if (quantaRemaining == 1)
-        {
+        } else if (quantaRemaining == 1) {
             return;
         }
 
@@ -112,24 +96,20 @@
         int total = quantaRemaining;
         int count = 1;
 
-        for (EnumFacing side : EnumFacing.Plane.HORIZONTAL)
-        {
+        for (EnumFacing side : EnumFacing.Plane.HORIZONTAL) {
             BlockPos off = pos.offset(side);
             if (displaceIfPossible(world, off))
                 world.setBlockToAir(off);
 
             int quanta = getQuantaValueBelow(world, off, lowerThan);
-            if (quanta >= 0)
-            {
+            if (quanta >= 0) {
                 count++;
                 total += quanta;
             }
         }
 
-        if (count == 1)
-        {
-            if (changed)
-            {
+        if (count == 1) {
+            if (changed) {
                 world.setBlockState(pos, state.withProperty(LEVEL, quantaRemaining - 1), Constants.BlockFlags.SEND_TO_CLIENTS);
             }
             return;
@@ -138,27 +118,20 @@
         int each = total / count;
         int rem = total % count;
 
-        for (EnumFacing side : EnumFacing.Plane.HORIZONTAL)
-        {
+        for (EnumFacing side : EnumFacing.Plane.HORIZONTAL) {
             BlockPos off = pos.offset(side);
             int quanta = getQuantaValueBelow(world, off, lowerThan);
-            if (quanta >= 0)
-            {
+            if (quanta >= 0) {
                 int newQuanta = each;
-                if (rem == count || rem > 1 && rand.nextInt(count - rem) != 0)
-                {
+                if (rem == count || rem > 1 && rand.nextInt(count - rem) != 0) {
                     ++newQuanta;
                     --rem;
                 }
 
-                if (newQuanta != quanta)
-                {
-                    if (newQuanta == 0)
-                    {
+                if (newQuanta != quanta) {
+                    if (newQuanta == 0) {
                         world.setBlockToAir(off);
-                    }
-                    else
-                    {
+                    } else {
                         world.setBlockState(off, getDefaultState().withProperty(LEVEL, newQuanta - 1), Constants.BlockFlags.SEND_TO_CLIENTS);
                     }
                     world.scheduleUpdate(off, this, tickRate);
@@ -167,80 +140,63 @@
             }
         }
 
-        if (rem > 0)
-        {
+        if (rem > 0) {
             ++each;
         }
         world.setBlockState(pos, state.withProperty(LEVEL, each - 1), Constants.BlockFlags.SEND_TO_CLIENTS);
     }
 
-    public int tryToFlowVerticallyInto(World world, BlockPos pos, int amtToInput)
-    {
+    public int tryToFlowVerticallyInto(World world, BlockPos pos, int amtToInput) {
         IBlockState myState = world.getBlockState(pos);
         BlockPos other = pos.add(0, densityDir, 0);
-        if (other.getY() < 0 || other.getY() >= world.getHeight())
-        {
+        if (other.getY() < 0 || other.getY() >= world.getHeight()) {
             world.setBlockToAir(pos);
             return 0;
         }
 
         int amt = getQuantaValueBelow(world, other, quantaPerBlock);
-        if (amt >= 0)
-        {
+        if (amt >= 0) {
             amt += amtToInput;
-            if (amt > quantaPerBlock)
-            {
+            if (amt > quantaPerBlock) {
                 world.setBlockState(other, myState.withProperty(LEVEL, quantaPerBlock - 1));
                 world.scheduleUpdate(other, this, tickRate);
                 return amt - quantaPerBlock;
-            }
-            else if (amt > 0)
-            {
+            } else if (amt > 0) {
                 world.setBlockState(other, myState.withProperty(LEVEL, amt - 1));
                 world.scheduleUpdate(other, this, tickRate);
                 world.setBlockToAir(pos);
                 return 0;
             }
             return amtToInput;
-        }
-        else
-        {
+        } else {
             int density_other = getDensity(world, other);
-            if (density_other == Integer.MAX_VALUE)
-            {
-                if (displaceIfPossible(world, other))
-                {
+            if (density_other == Integer.MAX_VALUE) {
+                if (displaceIfPossible(world, other)) {
                     world.setBlockState(other, myState.withProperty(LEVEL, amtToInput - 1));
                     world.scheduleUpdate(other, this, tickRate);
                     world.setBlockToAir(pos);
                     return 0;
-                }
-                else
-                {
+                } else {
                     return amtToInput;
                 }
             }
 
-            if (densityDir < 0)
-            {
+            if (densityDir < 0) {
                 if (density_other < density) // then swap
                 {
                     IBlockState state = world.getBlockState(other);
                     world.setBlockState(other, myState.withProperty(LEVEL, amtToInput - 1));
-                    world.setBlockState(pos,   state);
+                    world.setBlockState(pos, state);
                     world.scheduleUpdate(other, this, tickRate);
-                    world.scheduleUpdate(pos,   state.getBlock(), state.getBlock().tickRate(world));
+                    world.scheduleUpdate(pos, state.getBlock(), state.getBlock().tickRate(world));
                     return 0;
                 }
-            }
-            else
-            {
-                if (density_other > density)
-                {
+            } else {
+                if (density_other > density) {
                     IBlockState state = world.getBlockState(other);
                     world.setBlockState(other, myState.withProperty(LEVEL, amtToInput - 1));
                     world.setBlockState(pos, state);
-                    world.scheduleUpdate(other, this,  tickRate);
+                    world.scheduleUpdate(other, this, tickRate);
                     world.scheduleUpdate(pos, state.getBlock(), state.getBlock().tickRate(world));
                     return 0;
                 }
@@ -251,22 +207,19 @@
 
     /* IFluidBlock */
     @Override
-    public int place(World world, BlockPos pos, @Nonnull FluidStack fluidStack, boolean doPlace)
-    {
+    public int place(World world, BlockPos pos, @Nonnull FluidStack fluidStack, boolean doPlace) {
         IBlockState existing = world.getBlockState(pos);
         float quantaAmount = Fluid.BUCKET_VOLUME / quantaPerBlockFloat;
         // If the stack contains more available fluid than the full source block,
         // set a source block
         int closest = Fluid.BUCKET_VOLUME;
         int quanta = quantaPerBlock;
-        if (fluidStack.amount < closest)
-        {
+        if (fluidStack.amount < closest) {
             // Figure out maximum level to match stack amount
             closest = MathHelper.floor(quantaAmount * MathHelper.floor(fluidStack.amount / quantaAmount));
             quanta = MathHelper.floor(closest / quantaAmount);
         }
-        if (existing.getBlock() == this)
-        {
+        if (existing.getBlock() == this) {
             int existingQuanta = existing.getValue(LEVEL) + 1;
             int missingQuanta = quantaPerBlock - existingQuanta;
             closest = Math.min(closest, MathHelper.floor(missingQuanta * quantaAmount));
@@ -277,8 +230,7 @@
         if (quanta < 1 || quanta > 16)
             return 0;
 
-        if (doPlace)
-        {
+        if (doPlace) {
             FluidUtil.destroyBlockOnFluidPlacement(world, pos);
             world.setBlockState(pos, getDefaultState().withProperty(LEVEL, quanta - 1), Constants.BlockFlags.DEFAULT_AND_RERENDER);
         }
@@ -287,12 +239,10 @@
     }
 
     @Override
-    public FluidStack drain(World world, BlockPos pos, boolean doDrain)
-    {
+    public FluidStack drain(World world, BlockPos pos, boolean doDrain) {
         final FluidStack fluidStack = new FluidStack(getFluid(), MathHelper.floor(getQuantaPercentage(world, pos) * Fluid.BUCKET_VOLUME));
 
-        if (doDrain)
-        {
+        if (doDrain) {
             world.setBlockToAir(pos);
         }
 
@@ -300,8 +250,7 @@
     }
 
     @Override
-    public boolean canDrain(World world, BlockPos pos)
-    {
+    public boolean canDrain(World world, BlockPos pos) {
         return true;
     }
 }

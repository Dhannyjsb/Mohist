--- ../src-base/minecraft/net/minecraftforge/client/MinecraftForgeClient.java
+++ ../src-work/minecraft/net/minecraftforge/client/MinecraftForgeClient.java
@@ -19,16 +19,9 @@
 
 package net.minecraftforge.client;
 
-import java.awt.image.BufferedImage;
-import java.io.IOException;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.concurrent.TimeUnit;
-import java.util.function.Supplier;
-
-import javax.annotation.Nonnull;
-
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
 import net.minecraft.client.Minecraft;
 import net.minecraft.client.renderer.texture.TextureUtil;
 import net.minecraft.client.resources.IResource;
@@ -38,22 +31,40 @@
 import net.minecraft.util.math.BlockPos;
 import net.minecraft.world.ChunkCache;
 import net.minecraft.world.World;
-
 import org.apache.commons.lang3.tuple.Pair;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
+import javax.annotation.Nonnull;
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
 
-public class MinecraftForgeClient
-{
-    public static int getRenderPass()
-    {
+public class MinecraftForgeClient {
+    private static final LoadingCache<Pair<World, BlockPos>, ChunkCache> regionCache = CacheBuilder.newBuilder()
+            .maximumSize(500)
+            .concurrencyLevel(5)
+            .expireAfterAccess(1, TimeUnit.SECONDS)
+            .build(new CacheLoader<Pair<World, BlockPos>, ChunkCache>() {
+                @Override
+                public ChunkCache load(Pair<World, BlockPos> key) {
+                    return new ChunkCache(key.getLeft(), key.getRight().add(-1, -1, -1), key.getRight().add(16, 16, 16), 1);
+                }
+            });
+    private static BitSet stencilBits = new BitSet(8);
+    private static HashMap<ResourceLocation, Supplier<BufferedImage>> bufferedImageSuppliers = new HashMap<ResourceLocation, Supplier<BufferedImage>>();
+
+    static {
+        stencilBits.set(0, 8);
+    }
+
+    public static int getRenderPass() {
         return ForgeHooksClient.renderPass;
     }
 
-    public static BlockRenderLayer getRenderLayer()
-    {
+    public static BlockRenderLayer getRenderLayer() {
         return ForgeHooksClient.renderLayer.get();
     }
 
@@ -61,17 +72,10 @@
      * returns the Locale set by the player in Minecraft.
      * Useful for creating string and number formatters.
      */
-    public static Locale getLocale()
-    {
+    public static Locale getLocale() {
         return Minecraft.getMinecraft().getLanguageManager().getCurrentLanguage().getJavaLocale();
     }
 
-    private static BitSet stencilBits = new BitSet(8);
-    static
-    {
-        stencilBits.set(0,8);
-    }
-
     /**
      * Reserve a stencil bit for use in rendering
      *
@@ -80,11 +84,9 @@
      *
      * @return A bit or -1 if no further stencil bits are available
      */
-    public static int reserveStencilBit()
-    {
+    public static int reserveStencilBit() {
         int bit = stencilBits.nextSetBit(0);
-        if (bit >= 0)
-        {
+        if (bit >= 0) {
             stencilBits.clear(bit);
         }
         return bit;
@@ -95,55 +97,34 @@
      *
      * @param bit The bit from {@link #reserveStencilBit()}
      */
-    public static void releaseStencilBit(int bit)
-    {
-        if (bit >= 0 && bit < stencilBits.length())
-        {
+    public static void releaseStencilBit(int bit) {
+        if (bit >= 0 && bit < stencilBits.length()) {
             stencilBits.set(bit);
         }
     }
 
-    private static final LoadingCache<Pair<World, BlockPos>, ChunkCache> regionCache = CacheBuilder.newBuilder()
-        .maximumSize(500)
-        .concurrencyLevel(5)
-        .expireAfterAccess(1, TimeUnit.SECONDS)
-        .build(new CacheLoader<Pair<World, BlockPos>, ChunkCache>()
-        {
-            @Override
-            public ChunkCache load(Pair<World, BlockPos> key)
-            {
-                return new ChunkCache(key.getLeft(), key.getRight().add(-1, -1, -1), key.getRight().add(16, 16, 16), 1);
-            }
-        });
-
-    public static void onRebuildChunk(World world, BlockPos position, ChunkCache cache)
-    {
+    public static void onRebuildChunk(World world, BlockPos position, ChunkCache cache) {
         regionCache.put(Pair.of(world, position), cache);
     }
 
-    public static ChunkCache getRegionRenderCache(World world, BlockPos pos)
-    {
+    public static ChunkCache getRegionRenderCache(World world, BlockPos pos) {
         int x = pos.getX() & ~0xF;
         int y = pos.getY() & ~0xF;
         int z = pos.getZ() & ~0xF;
         return regionCache.getUnchecked(Pair.of(world, new BlockPos(x, y, z)));
     }
 
-    public static void clearRenderCache()
-    {
+    public static void clearRenderCache() {
         regionCache.invalidateAll();
         regionCache.cleanUp();
     }
 
-    private static HashMap<ResourceLocation, Supplier<BufferedImage>> bufferedImageSuppliers = new HashMap<ResourceLocation, Supplier<BufferedImage>>();
-    public static void registerImageLayerSupplier(ResourceLocation resourceLocation, Supplier<BufferedImage> supplier)
-    {
+    public static void registerImageLayerSupplier(ResourceLocation resourceLocation, Supplier<BufferedImage> supplier) {
         bufferedImageSuppliers.put(resourceLocation, supplier);
     }
 
     @Nonnull
-    public static BufferedImage getImageLayer(ResourceLocation resourceLocation, IResourceManager resourceManager) throws IOException
-    {
+    public static BufferedImage getImageLayer(ResourceLocation resourceLocation, IResourceManager resourceManager) throws IOException {
         Supplier<BufferedImage> supplier = bufferedImageSuppliers.get(resourceLocation);
         if (supplier != null)
             return supplier.get();

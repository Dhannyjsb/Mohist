--- ../src-base/minecraft/net/minecraftforge/client/model/ModelFluid.java
+++ ../src-work/minecraft/net/minecraftforge/client/model/ModelFluid.java
@@ -19,15 +19,14 @@
 
 package net.minecraftforge.client.model;
 
-import java.util.function.Function;
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Optional;
-
-import javax.annotation.Nullable;
-import javax.vecmath.Matrix4f;
-
+import com.google.common.cache.CacheBuilder;
+import com.google.common.cache.CacheLoader;
+import com.google.common.cache.LoadingCache;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonParser;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.renderer.block.model.BakedQuad;
 import net.minecraft.client.renderer.block.model.IBakedModel;
@@ -50,41 +49,35 @@
 import net.minecraftforge.fluids.Fluid;
 import net.minecraftforge.fluids.FluidRegistry;
 import net.minecraftforge.fml.common.FMLLog;
-
 import org.apache.commons.lang3.tuple.Pair;
 
-import com.google.common.cache.CacheBuilder;
-import com.google.common.cache.CacheLoader;
-import com.google.common.cache.LoadingCache;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.gson.JsonElement;
-import com.google.gson.JsonParser;
+import javax.annotation.Nullable;
+import javax.vecmath.Matrix4f;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Function;
 
-public final class ModelFluid implements IModel
-{
+public final class ModelFluid implements IModel {
     public static final ModelFluid WATER = new ModelFluid(FluidRegistry.WATER);
     public static final ModelFluid LAVA = new ModelFluid(FluidRegistry.LAVA);
 
     private final Fluid fluid;
 
-    public ModelFluid(Fluid fluid)
-    {
+    public ModelFluid(Fluid fluid) {
         this.fluid = fluid;
     }
 
     @Override
-    public Collection<ResourceLocation> getTextures()
-    {
+    public Collection<ResourceLocation> getTextures() {
         return fluid.getOverlay() != null
                 ? ImmutableSet.of(fluid.getStill(), fluid.getFlowing(), fluid.getOverlay())
                 : ImmutableSet.of(fluid.getStill(), fluid.getFlowing());
     }
 
     @Override
-    public IBakedModel bake(IModelState state, VertexFormat format, Function<ResourceLocation, TextureAtlasSprite> bakedTextureGetter)
-    {
+    public IBakedModel bake(IModelState state, VertexFormat format, Function<ResourceLocation, TextureAtlasSprite> bakedTextureGetter) {
         return new CachingBakedFluid(
                 state.apply(Optional.empty()),
                 PerspectiveMapWrapper.getTransforms(state),
@@ -98,49 +91,56 @@
         );
     }
 
-    public enum FluidLoader implements ICustomModelLoader
-    {
+    @Override
+    public ModelFluid process(ImmutableMap<String, String> customData) {
+        if (!customData.containsKey("fluid")) return this;
+
+        String fluidStr = customData.get("fluid");
+        JsonElement e = new JsonParser().parse(fluidStr);
+        String fluid = e.getAsString();
+        if (!FluidRegistry.isFluidRegistered(fluid)) {
+            FMLLog.log.fatal("fluid '{}' not found", fluid);
+            return WATER;
+        }
+        return new ModelFluid(FluidRegistry.getFluid(fluid));
+    }
+
+    public enum FluidLoader implements ICustomModelLoader {
         INSTANCE;
 
         @Override
-        public void onResourceManagerReload(IResourceManager resourceManager) {}
+        public void onResourceManagerReload(IResourceManager resourceManager) {
+        }
 
         @Override
-        public boolean accepts(ResourceLocation modelLocation)
-        {
+        public boolean accepts(ResourceLocation modelLocation) {
             return modelLocation.getResourceDomain().equals(ForgeVersion.MOD_ID) && (
-                modelLocation.getResourcePath().equals("fluid") ||
-                modelLocation.getResourcePath().equals("models/block/fluid") ||
-                modelLocation.getResourcePath().equals("models/item/fluid"));
+                    modelLocation.getResourcePath().equals("fluid") ||
+                            modelLocation.getResourcePath().equals("models/block/fluid") ||
+                            modelLocation.getResourcePath().equals("models/item/fluid"));
         }
 
         @Override
-        public IModel loadModel(ResourceLocation modelLocation)
-        {
+        public IModel loadModel(ResourceLocation modelLocation) {
             return WATER;
         }
     }
 
-    private static final class CachingBakedFluid extends BakedFluid
-    {
-        private final LoadingCache<Long, BakedFluid> modelCache = CacheBuilder.newBuilder().maximumSize(200).build(new CacheLoader<Long, BakedFluid>()
-        {
+    private static final class CachingBakedFluid extends BakedFluid {
+        private final LoadingCache<Long, BakedFluid> modelCache = CacheBuilder.newBuilder().maximumSize(200).build(new CacheLoader<Long, BakedFluid>() {
             @Override
-            public BakedFluid load(Long key)
-            {
+            public BakedFluid load(Long key) {
                 boolean statePresent = (key & 1) != 0;
                 key >>>= 1;
                 int[] cornerRound = new int[4];
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     cornerRound[i] = (int) (key & 0x3FF);
                     key >>>= 10;
                 }
                 int flowRound = (int) (key & 0x7FF) - 1024;
                 key >>>= 11;
                 boolean[] overlaySides = new boolean[4];
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     overlaySides[i] = (key & 1) != 0;
                     key >>>= 1;
                 }
@@ -148,8 +148,7 @@
             }
         });
 
-        public CachingBakedFluid(Optional<TRSRTransformation> transformation, ImmutableMap<TransformType, TRSRTransformation> transforms, VertexFormat format, int color, TextureAtlasSprite still, TextureAtlasSprite flowing, Optional<TextureAtlasSprite> overlay, boolean gas, Optional<IExtendedBlockState> stateOption)
-        {
+        public CachingBakedFluid(Optional<TRSRTransformation> transformation, ImmutableMap<TransformType, TRSRTransformation> transforms, VertexFormat format, int color, TextureAtlasSprite still, TextureAtlasSprite flowing, Optional<TextureAtlasSprite> overlay, boolean gas, Optional<IExtendedBlockState> stateOption) {
             super(transformation, transforms, format, color, still, flowing, overlay, gas, stateOption.isPresent(), getCorners(stateOption), getFlow(stateOption), getOverlay(stateOption));
         }
 
@@ -162,14 +161,11 @@
          * while also providing good use of the available value range.
          * (For fluids with default quanta, this evenly divides the per-block intervals of 1/9 by 96)
          */
-        private static int[] getCorners(Optional<IExtendedBlockState> stateOption)
-        {
+        private static int[] getCorners(Optional<IExtendedBlockState> stateOption) {
             int[] cornerRound = {0, 0, 0, 0};
-            if (stateOption.isPresent())
-            {
+            if (stateOption.isPresent()) {
                 IExtendedBlockState state = stateOption.get();
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     Float level = state.getValue(BlockFluidBase.LEVEL_CORNERS[i]);
                     cornerRound[i] = Math.round((level == null ? 8f / 9f : level) * 864);
                 }
@@ -184,11 +180,9 @@
          * The value is currently stored as the angle rounded to the nearest degree.
          * A value of -1000 is used to signify no flow.
          */
-        private static int getFlow(Optional<IExtendedBlockState> stateOption)
-        {
+        private static int getFlow(Optional<IExtendedBlockState> stateOption) {
             Float flow = -1000f;
-            if (stateOption.isPresent())
-            {
+            if (stateOption.isPresent()) {
                 flow = stateOption.get().getValue(BlockFluidBase.FLOW_DIRECTION);
                 if (flow == null) flow = -1000f;
             }
@@ -204,14 +198,11 @@
          * instead of the normal "flowing" texture (if applicable for that fluid).
          * The sides are stored here by their regular horizontal index.
          */
-        private static boolean[] getOverlay(Optional<IExtendedBlockState> stateOption)
-        {
+        private static boolean[] getOverlay(Optional<IExtendedBlockState> stateOption) {
             boolean[] overlaySides = new boolean[4];
-            if (stateOption.isPresent())
-            {
+            if (stateOption.isPresent()) {
                 IExtendedBlockState state = stateOption.get();
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     Boolean overlay = state.getValue(BlockFluidBase.SIDE_OVERLAYS[i]);
                     if (overlay != null) overlaySides[i] = overlay;
                 }
@@ -220,26 +211,22 @@
         }
 
         @Override
-        public List<BakedQuad> getQuads(@Nullable IBlockState state, @Nullable EnumFacing side, long rand)
-        {
-            if (side != null && state instanceof IExtendedBlockState)
-            {
-                Optional<IExtendedBlockState> exState = Optional.of((IExtendedBlockState)state);
+        public List<BakedQuad> getQuads(@Nullable IBlockState state, @Nullable EnumFacing side, long rand) {
+            if (side != null && state instanceof IExtendedBlockState) {
+                Optional<IExtendedBlockState> exState = Optional.of((IExtendedBlockState) state);
 
                 int[] cornerRound = getCorners(exState);
                 int flowRound = getFlow(exState);
                 boolean[] overlaySides = getOverlay(exState);
 
                 long key = 0L;
-                for (int i = 3; i >= 0; i--)
-                {
+                for (int i = 3; i >= 0; i--) {
                     key <<= 1;
                     key |= overlaySides[i] ? 1 : 0;
                 }
                 key <<= 11;
                 key |= flowRound + 1024;
-                for (int i = 3; i >= 0; i--)
-                {
+                for (int i = 3; i >= 0; i--) {
                     key <<= 10;
                     key |= cornerRound[i];
                 }
@@ -253,10 +240,9 @@
         }
     }
 
-    private static class BakedFluid implements IBakedModel
-    {
-        private static final int x[] = { 0, 0, 1, 1 };
-        private static final int z[] = { 0, 1, 1, 0 };
+    private static class BakedFluid implements IBakedModel {
+        private static final int x[] = {0, 0, 1, 1};
+        private static final int z[] = {0, 1, 1, 0};
         private static final float eps = 1e-3f;
 
         protected final Optional<TRSRTransformation> transformation;
@@ -268,8 +254,7 @@
         protected final boolean gas;
         protected final ImmutableMap<EnumFacing, ImmutableList<BakedQuad>> faceQuads;
 
-        public BakedFluid(Optional<TRSRTransformation> transformation, ImmutableMap<TransformType, TRSRTransformation> transforms, VertexFormat format, int color, TextureAtlasSprite still, TextureAtlasSprite flowing, Optional<TextureAtlasSprite> overlay, boolean gas, boolean statePresent, int[] cornerRound, int flowRound, boolean[] sideOverlays)
-        {
+        public BakedFluid(Optional<TRSRTransformation> transformation, ImmutableMap<TransformType, TRSRTransformation> transforms, VertexFormat format, int color, TextureAtlasSprite still, TextureAtlasSprite flowing, Optional<TextureAtlasSprite> overlay, boolean gas, boolean statePresent, int[] cornerRound, int flowRound, boolean[] sideOverlays) {
             this.transformation = transformation;
             this.transforms = transforms;
             this.format = format;
@@ -281,21 +266,17 @@
             this.faceQuads = buildQuads(statePresent, cornerRound, flowRound, sideOverlays);
         }
 
-        private ImmutableMap<EnumFacing, ImmutableList<BakedQuad>> buildQuads(boolean statePresent, int[] cornerRound, int flowRound, boolean[] sideOverlays)
-        {
+        private ImmutableMap<EnumFacing, ImmutableList<BakedQuad>> buildQuads(boolean statePresent, int[] cornerRound, int flowRound, boolean[] sideOverlays) {
             EnumMap<EnumFacing, ImmutableList<BakedQuad>> faceQuads = new EnumMap<>(EnumFacing.class);
-            for (EnumFacing side : EnumFacing.values())
-            {
+            for (EnumFacing side : EnumFacing.values()) {
                 faceQuads.put(side, ImmutableList.of());
             }
 
-            if (statePresent)
-            {
+            if (statePresent) {
                 // y levels
                 float[] y = new float[4];
                 boolean fullVolume = true;
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     float value = cornerRound[i] / 864f;
                     if (value < 1f) fullVolume = false;
                     y[i] = gas ? 1f - value : value;
@@ -345,8 +326,7 @@
                 ));
 
                 // sides
-                for (int i = 0; i < 4; i++)
-                {
+                for (int i = 0; i < 4; i++) {
                     EnumFacing side = EnumFacing.getHorizontal((5 - i) % 4); // [W, S, E, N]
                     boolean useOverlay = overlay.isPresent() && sideOverlays[side.getHorizontalIndex()];
                     int si = i; // local var for lambda capture
@@ -359,14 +339,13 @@
 
                     ImmutableList.Builder<BakedQuad> builder = ImmutableList.builder();
 
-                    if (!useOverlay) builder.add(buildQuad(side, flowing, gas, true, sideX, sideY, sideZ, sideU, sideV));
+                    if (!useOverlay)
+                        builder.add(buildQuad(side, flowing, gas, true, sideX, sideY, sideZ, sideU, sideV));
                     builder.add(buildQuad(side, useOverlay ? overlay.get() : flowing, !gas, false, sideX, sideY, sideZ, sideU, sideV));
 
                     faceQuads.put(side, builder.build());
                 }
-            }
-            else
-            {
+            } else {
                 // inventory
                 faceQuads.put(EnumFacing.SOUTH, ImmutableList.of(
                         buildQuad(EnumFacing.UP, still, false, false,
@@ -382,14 +361,7 @@
             return ImmutableMap.copyOf(faceQuads);
         }
 
-        // maps vertex index to parameter value
-        private interface VertexParameter
-        {
-            float get(int index);
-        }
-
-        private BakedQuad buildQuad(EnumFacing side, TextureAtlasSprite texture, boolean flip, boolean offset, VertexParameter x, VertexParameter y, VertexParameter z, VertexParameter u, VertexParameter v)
-        {
+        private BakedQuad buildQuad(EnumFacing side, TextureAtlasSprite texture, boolean flip, boolean offset, VertexParameter x, VertexParameter y, VertexParameter z, VertexParameter u, VertexParameter v) {
             UnpackedBakedQuad.Builder builder = new UnpackedBakedQuad.Builder(format);
 
             builder.setQuadOrientation(side);
@@ -399,115 +371,92 @@
             boolean hasTransform = transformation.isPresent() && !transformation.get().isIdentity();
             IVertexConsumer consumer = hasTransform ? new TRSRTransformer(builder, transformation.get()) : builder;
 
-            for (int i = 0; i < 4; i++)
-            {
+            for (int i = 0; i < 4; i++) {
                 int vertex = flip ? 3 - i : i;
                 putVertex(
-                    consumer, side, offset,
-                    x.get(vertex), y.get(vertex), z.get(vertex),
-                    texture.getInterpolatedU(u.get(vertex)),
-                    texture.getInterpolatedV(v.get(vertex))
+                        consumer, side, offset,
+                        x.get(vertex), y.get(vertex), z.get(vertex),
+                        texture.getInterpolatedU(u.get(vertex)),
+                        texture.getInterpolatedV(v.get(vertex))
                 );
             }
 
             return builder.build();
         }
 
-        private void putVertex(IVertexConsumer consumer, EnumFacing side, boolean offset, float x, float y, float z, float u, float v)
-        {
-            for(int e = 0; e < format.getElementCount(); e++)
-            {
-                switch(format.getElement(e).getUsage())
-                {
-                case POSITION:
-                    float dx = offset ? side.getDirectionVec().getX() * eps : 0f;
-                    float dy = offset ? side.getDirectionVec().getY() * eps : 0f;
-                    float dz = offset ? side.getDirectionVec().getZ() * eps : 0f;
-                    consumer.put(e, x - dx, y - dy, z - dz, 1f);
-                    break;
-                case COLOR:
-                    float r = ((color >> 16) & 0xFF) / 255f;
-                    float g = ((color >>  8) & 0xFF) / 255f;
-                    float b = ( color        & 0xFF) / 255f;
-                    float a = ((color >> 24) & 0xFF) / 255f;
-                    consumer.put(e, r, g, b, a);
-                    break;
-                case NORMAL:
-                    float offX = (float) side.getFrontOffsetX();
-                    float offY = (float) side.getFrontOffsetY();
-                    float offZ = (float) side.getFrontOffsetZ();
-                    consumer.put(e, offX, offY, offZ, 0f);
-                    break;
-                case UV:
-                    if(format.getElement(e).getIndex() == 0)
-                    {
-                        consumer.put(e, u, v, 0f, 1f);
+        private void putVertex(IVertexConsumer consumer, EnumFacing side, boolean offset, float x, float y, float z, float u, float v) {
+            for (int e = 0; e < format.getElementCount(); e++) {
+                switch (format.getElement(e).getUsage()) {
+                    case POSITION:
+                        float dx = offset ? side.getDirectionVec().getX() * eps : 0f;
+                        float dy = offset ? side.getDirectionVec().getY() * eps : 0f;
+                        float dz = offset ? side.getDirectionVec().getZ() * eps : 0f;
+                        consumer.put(e, x - dx, y - dy, z - dz, 1f);
                         break;
-                    }
-                    // else fallthrough to default
-                default:
-                    consumer.put(e);
-                    break;
+                    case COLOR:
+                        float r = ((color >> 16) & 0xFF) / 255f;
+                        float g = ((color >> 8) & 0xFF) / 255f;
+                        float b = (color & 0xFF) / 255f;
+                        float a = ((color >> 24) & 0xFF) / 255f;
+                        consumer.put(e, r, g, b, a);
+                        break;
+                    case NORMAL:
+                        float offX = (float) side.getFrontOffsetX();
+                        float offY = (float) side.getFrontOffsetY();
+                        float offZ = (float) side.getFrontOffsetZ();
+                        consumer.put(e, offX, offY, offZ, 0f);
+                        break;
+                    case UV:
+                        if (format.getElement(e).getIndex() == 0) {
+                            consumer.put(e, u, v, 0f, 1f);
+                            break;
+                        }
+                        // else fallthrough to default
+                    default:
+                        consumer.put(e);
+                        break;
                 }
             }
         }
 
         @Override
-        public boolean isAmbientOcclusion()
-        {
+        public boolean isAmbientOcclusion() {
             return true;
         }
 
         @Override
-        public boolean isGui3d()
-        {
+        public boolean isGui3d() {
             return false;
         }
 
         @Override
-        public boolean isBuiltInRenderer()
-        {
+        public boolean isBuiltInRenderer() {
             return false;
         }
 
         @Override
-        public TextureAtlasSprite getParticleTexture()
-        {
+        public TextureAtlasSprite getParticleTexture() {
             return still;
         }
 
         @Override
-        public List<BakedQuad> getQuads(@Nullable IBlockState state, @Nullable EnumFacing side, long rand)
-        {
+        public List<BakedQuad> getQuads(@Nullable IBlockState state, @Nullable EnumFacing side, long rand) {
             return side == null ? ImmutableList.of() : faceQuads.get(side);
         }
 
         @Override
-        public ItemOverrideList getOverrides()
-        {
+        public ItemOverrideList getOverrides() {
             return ItemOverrideList.NONE;
         }
 
         @Override
-        public Pair<? extends IBakedModel, Matrix4f> handlePerspective(TransformType type)
-        {
+        public Pair<? extends IBakedModel, Matrix4f> handlePerspective(TransformType type) {
             return PerspectiveMapWrapper.handlePerspective(this, transforms, type);
         }
-    }
 
-    @Override
-    public ModelFluid process(ImmutableMap<String, String> customData)
-    {
-        if(!customData.containsKey("fluid")) return this;
-
-        String fluidStr = customData.get("fluid");
-        JsonElement e = new JsonParser().parse(fluidStr);
-        String fluid = e.getAsString();
-        if(!FluidRegistry.isFluidRegistered(fluid))
-        {
-            FMLLog.log.fatal("fluid '{}' not found", fluid);
-            return WATER;
+        // maps vertex index to parameter value
+        private interface VertexParameter {
+            float get(int index);
         }
-        return new ModelFluid(FluidRegistry.getFluid(fluid));
     }
 }

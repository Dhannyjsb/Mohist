--- ../src-base/minecraft/net/minecraftforge/client/model/pipeline/ForgeBlockModelRenderer.java
+++ ../src-work/minecraft/net/minecraftforge/client/model/pipeline/ForgeBlockModelRenderer.java
@@ -19,8 +19,6 @@
 
 package net.minecraftforge.client.model.pipeline;
 
-import java.util.List;
-
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.client.renderer.BlockModelRenderer;
 import net.minecraft.client.renderer.BufferBuilder;
@@ -32,25 +30,52 @@
 import net.minecraft.world.IBlockAccess;
 import net.minecraftforge.common.ForgeModContainer;
 
-public class ForgeBlockModelRenderer extends BlockModelRenderer
-{
+import java.util.List;
+
+public class ForgeBlockModelRenderer extends BlockModelRenderer {
     private final ThreadLocal<VertexLighterFlat> lighterFlat;
     private final ThreadLocal<VertexLighterSmoothAo> lighterSmooth;
     private final ThreadLocal<VertexBufferConsumer> consumerFlat = ThreadLocal.withInitial(VertexBufferConsumer::new);
     private final ThreadLocal<VertexBufferConsumer> consumerSmooth = ThreadLocal.withInitial(VertexBufferConsumer::new);
 
-    public ForgeBlockModelRenderer(BlockColors colors)
-    {
+    public ForgeBlockModelRenderer(BlockColors colors) {
         super(colors);
         lighterFlat = ThreadLocal.withInitial(() -> new VertexLighterFlat(colors));
         lighterSmooth = ThreadLocal.withInitial(() -> new VertexLighterSmoothAo(colors));
     }
 
+    public static boolean render(VertexLighterFlat lighter, IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder wr, boolean checkSides, long rand) {
+        lighter.setWorld(world);
+        lighter.setState(state);
+        lighter.setBlockPos(pos);
+        boolean empty = true;
+        List<BakedQuad> quads = model.getQuads(state, null, rand);
+        if (!quads.isEmpty()) {
+            lighter.updateBlockInfo();
+            empty = false;
+            for (BakedQuad quad : quads) {
+                quad.pipe(lighter);
+            }
+        }
+        for (EnumFacing side : EnumFacing.values()) {
+            quads = model.getQuads(state, side, rand);
+            if (!quads.isEmpty()) {
+                if (!checkSides || state.shouldSideBeRendered(world, pos, side)) {
+                    if (empty) lighter.updateBlockInfo();
+                    empty = false;
+                    for (BakedQuad quad : quads) {
+                        quad.pipe(lighter);
+                    }
+                }
+            }
+        }
+        lighter.resetBlockInfo();
+        return !empty;
+    }
+
     @Override
-    public boolean renderModelFlat(IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder buffer, boolean checkSides, long rand)
-    {
-        if(ForgeModContainer.forgeLightPipelineEnabled)
-        {
+    public boolean renderModelFlat(IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder buffer, boolean checkSides, long rand) {
+        if (ForgeModContainer.forgeLightPipelineEnabled) {
             VertexBufferConsumer consumer = consumerFlat.get();
             consumer.setBuffer(buffer);
             consumer.setOffset(pos);
@@ -59,18 +84,14 @@
             lighter.setParent(consumer);
 
             return render(lighter, world, model, state, pos, buffer, checkSides, rand);
-        }
-        else
-        {
+        } else {
             return super.renderModelFlat(world, model, state, pos, buffer, checkSides, rand);
         }
     }
 
     @Override
-    public boolean renderModelSmooth(IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder buffer, boolean checkSides, long rand)
-    {
-        if(ForgeModContainer.forgeLightPipelineEnabled)
-        {
+    public boolean renderModelSmooth(IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder buffer, boolean checkSides, long rand) {
+        if (ForgeModContainer.forgeLightPipelineEnabled) {
             VertexBufferConsumer consumer = consumerSmooth.get();
             consumer.setBuffer(buffer);
             consumer.setOffset(pos);
@@ -79,46 +100,8 @@
             lighter.setParent(consumer);
 
             return render(lighter, world, model, state, pos, buffer, checkSides, rand);
-        }
-        else
-        {
+        } else {
             return super.renderModelSmooth(world, model, state, pos, buffer, checkSides, rand);
         }
     }
-
-    public static boolean render(VertexLighterFlat lighter, IBlockAccess world, IBakedModel model, IBlockState state, BlockPos pos, BufferBuilder wr, boolean checkSides, long rand)
-    {
-        lighter.setWorld(world);
-        lighter.setState(state);
-        lighter.setBlockPos(pos);
-        boolean empty = true;
-        List<BakedQuad> quads = model.getQuads(state, null, rand);
-        if(!quads.isEmpty())
-        {
-            lighter.updateBlockInfo();
-            empty = false;
-            for(BakedQuad quad : quads)
-            {
-                quad.pipe(lighter);
-            }
-        }
-        for(EnumFacing side : EnumFacing.values())
-        {
-            quads = model.getQuads(state, side, rand);
-            if(!quads.isEmpty())
-            {
-                if(!checkSides || state.shouldSideBeRendered(world, pos, side))
-                {
-                    if(empty) lighter.updateBlockInfo();
-                    empty = false;
-                    for(BakedQuad quad : quads)
-                    {
-                        quad.pipe(lighter);
-                    }
-                }
-            }
-        }
-        lighter.resetBlockInfo();
-        return !empty;
-    }
 }

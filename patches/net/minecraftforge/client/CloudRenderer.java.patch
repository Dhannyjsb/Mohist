--- ../src-base/minecraft/net/minecraftforge/client/CloudRenderer.java
+++ ../src-work/minecraft/net/minecraftforge/client/CloudRenderer.java
@@ -19,21 +19,8 @@
 
 package net.minecraftforge.client;
 
-import javax.annotation.Nonnull;
-import java.nio.ByteBuffer;
-import java.util.function.Predicate;
-
-import net.minecraftforge.client.resource.IResourceType;
-import net.minecraftforge.client.resource.VanillaResourceType;
-import org.lwjgl.opengl.GL11;
-
 import net.minecraft.client.Minecraft;
-import net.minecraft.client.renderer.BufferBuilder;
-import net.minecraft.client.renderer.EntityRenderer;
-import net.minecraft.client.renderer.GLAllocation;
-import net.minecraft.client.renderer.GlStateManager;
-import net.minecraft.client.renderer.OpenGlHelper;
-import net.minecraft.client.renderer.Tessellator;
+import net.minecraft.client.renderer.*;
 import net.minecraft.client.renderer.texture.DynamicTexture;
 import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
 import net.minecraft.client.renderer.vertex.VertexBuffer;
@@ -44,17 +31,23 @@
 import net.minecraft.util.ResourceLocation;
 import net.minecraft.util.math.MathHelper;
 import net.minecraft.util.math.Vec3d;
-import net.minecraftforge.common.ForgeModContainer;
+import net.minecraftforge.client.resource.IResourceType;
 import net.minecraftforge.client.resource.ISelectiveResourceReloadListener;
+import net.minecraftforge.client.resource.VanillaResourceType;
+import net.minecraftforge.common.ForgeModContainer;
+import org.lwjgl.opengl.GL11;
 
-public class CloudRenderer implements ISelectiveResourceReloadListener
-{
+import javax.annotation.Nonnull;
+import java.nio.ByteBuffer;
+import java.util.function.Predicate;
+
+public class CloudRenderer implements ISelectiveResourceReloadListener {
     // Shared constants.
     private static final float PX_SIZE = 1 / 256F;
 
     // Building constants.
     private static final VertexFormat FORMAT = DefaultVertexFormats.POSITION_TEX_COLOR;
-    private static final int TOP_SECTIONS = 12;	// Number of slices a top face will span.
+    private static final int TOP_SECTIONS = 12;    // Number of slices a top face will span.
     private static final int HEIGHT = 4;
     private static final float INSET = 0.001F;
     private static final float ALPHA = 0.8F;
@@ -76,25 +69,21 @@
     private int texW;
     private int texH;
 
-    public CloudRenderer()
-    {
+    public CloudRenderer() {
         // Resource manager should always be reloadable.
         ((IReloadableResourceManager) mc.getResourceManager()).registerReloadListener(this);
     }
 
-    private int getScale()
-    {
+    private int getScale() {
         return cloudMode == 2 ? 12 : 8;
     }
 
-    private float ceilToScale(float value)
-    {
+    private float ceilToScale(float value) {
         float scale = getScale();
         return MathHelper.ceil(value / scale) * scale;
     }
 
-    private void vertices(BufferBuilder buffer)
-    {
+    private void vertices(BufferBuilder buffer) {
         boolean fancy = cloudMode == 2;    // Defines whether to hide all but the bottom.
 
         float scale = getScale();
@@ -113,8 +102,7 @@
         float sectX0 = sectStart;
         float sectX1 = sectX0;
 
-        while (sectX1 < sectEnd)
-        {
+        while (sectX1 < sectEnd) {
             sectX1 += sectStep;
 
             if (sectX1 > sectEnd)
@@ -123,8 +111,7 @@
             float sectZ0 = sectStart;
             float sectZ1 = sectZ0;
 
-            while (sectZ1 < sectEnd)
-            {
+            while (sectZ1 < sectEnd) {
                 sectZ1 += sectStep;
 
                 if (sectZ1 > sectEnd)
@@ -141,8 +128,7 @@
                 buffer.pos(sectX1, 0, sectZ1).tex(u1, v1).color(bCol, bCol, bCol, ALPHA).endVertex();
                 buffer.pos(sectX0, 0, sectZ1).tex(u0, v1).color(bCol, bCol, bCol, ALPHA).endVertex();
 
-                if (fancy)
-                {
+                if (fancy) {
                     // Top
                     buffer.pos(sectX0, HEIGHT, sectZ0).tex(u0, v0).color(1, 1, 1, ALPHA).endVertex();
                     buffer.pos(sectX0, HEIGHT, sectZ1).tex(u0, v1).color(1, 1, 1, ALPHA).endVertex();
@@ -153,60 +139,54 @@
                     float sliceCoord0;
                     float sliceCoord1;
 
-                    for (slice = sectX0; slice < sectX1;)
-                    {
+                    for (slice = sectX0; slice < sectX1; ) {
                         sliceCoord0 = slice * sectPx;
                         sliceCoord1 = sliceCoord0 + PX_SIZE;
 
                         // X sides
-                        if (slice > -CULL_DIST)
-                        {
+                        if (slice > -CULL_DIST) {
                             slice += INSET;
-                            buffer.pos(slice, 0,      sectZ1).tex(sliceCoord0, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
+                            buffer.pos(slice, 0, sectZ1).tex(sliceCoord0, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             buffer.pos(slice, HEIGHT, sectZ1).tex(sliceCoord1, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             buffer.pos(slice, HEIGHT, sectZ0).tex(sliceCoord1, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
-                            buffer.pos(slice, 0,      sectZ0).tex(sliceCoord0, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
+                            buffer.pos(slice, 0, sectZ0).tex(sliceCoord0, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             slice -= INSET;
                         }
 
                         slice += scale;
 
-                        if (slice <= CULL_DIST)
-                        {
+                        if (slice <= CULL_DIST) {
                             slice -= INSET;
-                            buffer.pos(slice, 0,      sectZ0).tex(sliceCoord0, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
+                            buffer.pos(slice, 0, sectZ0).tex(sliceCoord0, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             buffer.pos(slice, HEIGHT, sectZ0).tex(sliceCoord1, v0).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             buffer.pos(slice, HEIGHT, sectZ1).tex(sliceCoord1, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
-                            buffer.pos(slice, 0,      sectZ1).tex(sliceCoord0, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
+                            buffer.pos(slice, 0, sectZ1).tex(sliceCoord0, v1).color(0.9F, 0.9F, 0.9F, ALPHA).endVertex();
                             slice += INSET;
                         }
                     }
 
-                    for (slice = sectZ0; slice < sectZ1;)
-                    {
+                    for (slice = sectZ0; slice < sectZ1; ) {
                         sliceCoord0 = slice * sectPx;
                         sliceCoord1 = sliceCoord0 + PX_SIZE;
 
                         // Z sides
-                        if (slice > -CULL_DIST)
-                        {
+                        if (slice > -CULL_DIST) {
                             slice += INSET;
-                            buffer.pos(sectX0, 0,      slice).tex(u0, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
+                            buffer.pos(sectX0, 0, slice).tex(u0, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             buffer.pos(sectX0, HEIGHT, slice).tex(u0, sliceCoord1).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             buffer.pos(sectX1, HEIGHT, slice).tex(u1, sliceCoord1).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
-                            buffer.pos(sectX1, 0,      slice).tex(u1, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
+                            buffer.pos(sectX1, 0, slice).tex(u1, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             slice -= INSET;
                         }
 
                         slice += scale;
 
-                        if (slice <= CULL_DIST)
-                        {
+                        if (slice <= CULL_DIST) {
                             slice -= INSET;
-                            buffer.pos(sectX1, 0,      slice).tex(u1, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
+                            buffer.pos(sectX1, 0, slice).tex(u1, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             buffer.pos(sectX1, HEIGHT, slice).tex(u1, sliceCoord1).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             buffer.pos(sectX0, HEIGHT, slice).tex(u0, sliceCoord1).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
-                            buffer.pos(sectX0, 0,      slice).tex(u0, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
+                            buffer.pos(sectX0, 0, slice).tex(u0, sliceCoord0).color(0.8F, 0.8F, 0.8F, ALPHA).endVertex();
                             slice += INSET;
                         }
                     }
@@ -219,22 +199,18 @@
         }
     }
 
-    private void dispose()
-    {
-        if (vbo != null)
-        {
+    private void dispose() {
+        if (vbo != null) {
             vbo.deleteGlBuffers();
             vbo = null;
         }
-        if (displayList >= 0)
-        {
+        if (displayList >= 0) {
             GLAllocation.deleteDisplayLists(displayList);
             displayList = -1;
         }
     }
 
-    private void build()
-    {
+    private void build() {
         Tessellator tess = Tessellator.getInstance();
         BufferBuilder buffer = tess.getBuffer();
 
@@ -245,55 +221,46 @@
 
         vertices(buffer);
 
-        if (OpenGlHelper.useVbo())
-        {
+        if (OpenGlHelper.useVbo()) {
             buffer.finishDrawing();
             buffer.reset();
             vbo.bufferData(buffer.getByteBuffer());
-        }
-        else
-        {
+        } else {
             tess.draw();
             GlStateManager.glEndList();
         }
     }
 
-    private int fullCoord(double coord, int scale)
-    {   // Corrects misalignment of UV offset when on negative coords.
+    private int fullCoord(double coord, int scale) {   // Corrects misalignment of UV offset when on negative coords.
         return ((int) coord / scale) - (coord < 0 ? 1 : 0);
     }
 
-    private boolean isBuilt()
-    {
+    private boolean isBuilt() {
         return OpenGlHelper.useVbo() ? vbo != null : displayList >= 0;
     }
 
-    public void checkSettings()
-    {
+    public void checkSettings() {
         boolean newEnabled = ForgeModContainer.forgeCloudsEnabled
                 && mc.gameSettings.shouldRenderClouds() != 0
                 && mc.world != null
                 && mc.world.provider.isSurfaceWorld();
 
         if (isBuilt()
-                    && (!newEnabled
-                    || mc.gameSettings.shouldRenderClouds() != cloudMode
-                    || mc.gameSettings.renderDistanceChunks != renderDistance))
-        {
+                && (!newEnabled
+                || mc.gameSettings.shouldRenderClouds() != cloudMode
+                || mc.gameSettings.renderDistanceChunks != renderDistance)) {
             dispose();
         }
 
         cloudMode = mc.gameSettings.shouldRenderClouds();
         renderDistance = mc.gameSettings.renderDistanceChunks;
 
-        if (newEnabled && !isBuilt())
-        {
+        if (newEnabled && !isBuilt()) {
             build();
         }
     }
 
-    public boolean render(int cloudTicks, float partialTicks)
-    {
+    public boolean render(int cloudTicks, float partialTicks) {
         if (!isBuilt())
             return false;
 
@@ -344,8 +311,7 @@
         float g = (float) color.y;
         float b = (float) color.z;
 
-        if (mc.gameSettings.anaglyph)
-        {
+        if (mc.gameSettings.anaglyph) {
             float tempR = r * 0.3F + g * 0.59F + b * 0.11F;
             float tempG = r * 0.3F + g * 0.7F;
             float tempB = r * 0.3F + b * 0.7F;
@@ -375,8 +341,7 @@
         ByteBuffer buffer = Tessellator.getInstance().getBuffer().getByteBuffer();
 
         // Set up pointers for the display list/VBO.
-        if (OpenGlHelper.useVbo())
-        {
+        if (OpenGlHelper.useVbo()) {
             vbo.bindBuffer();
 
             int stride = FORMAT.getNextOffset();
@@ -386,9 +351,7 @@
             GlStateManager.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);
             GlStateManager.glColorPointer(4, GL11.GL_UNSIGNED_BYTE, stride, 20);
             GlStateManager.glEnableClientState(GL11.GL_COLOR_ARRAY);
-        }
-        else
-        {
+        } else {
             buffer.limit(FORMAT.getNextOffset());
             for (int i = 0; i < FORMAT.getElementCount(); i++)
                 FORMAT.getElements().get(i).getUsage().preDraw(FORMAT, i, FORMAT.getNextOffset(), buffer);
@@ -403,26 +366,21 @@
             GlStateManager.callList(displayList);
 
         // Full render.
-        if (!mc.gameSettings.anaglyph)
-        {
+        if (!mc.gameSettings.anaglyph) {
             GlStateManager.colorMask(true, true, true, true);
-        }
-        else
-        {
-            switch (EntityRenderer.anaglyphField)
-            {
-            case 0:
-                GlStateManager.colorMask(false, true, true, true);
-                break;
-            case 1:
-                GlStateManager.colorMask(true, false, false, true);
-                break;
+        } else {
+            switch (EntityRenderer.anaglyphField) {
+                case 0:
+                    GlStateManager.colorMask(false, true, true, true);
+                    break;
+                case 1:
+                    GlStateManager.colorMask(true, false, false, true);
+                    break;
             }
         }
 
         // Wireframe for debug.
-        if (WIREFRAME)
-        {
+        if (WIREFRAME) {
             GlStateManager.glPolygonMode(GL11.GL_FRONT_AND_BACK, GL11.GL_LINE);
             GlStateManager.glLineWidth(2.0F);
             GlStateManager.disableTexture2D();
@@ -438,13 +396,10 @@
             GlStateManager.enableFog();
         }
 
-        if (OpenGlHelper.useVbo())
-        {
+        if (OpenGlHelper.useVbo()) {
             vbo.drawArrays(GL11.GL_QUADS);
             vbo.unbindBuffer(); // Unbind buffer and disable pointers.
-        }
-        else
-        {
+        } else {
             GlStateManager.callList(displayList);
         }
 
@@ -471,10 +426,8 @@
         return true;
     }
 
-    private void reloadTextures()
-    {
-        if (mc.renderEngine != null)
-        {
+    private void reloadTextures() {
+        if (mc.renderEngine != null) {
             mc.renderEngine.bindTexture(texture);
             texW = GlStateManager.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
             texH = GlStateManager.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
@@ -482,10 +435,8 @@
     }
 
     @Override
-    public void onResourceManagerReload(@Nonnull IResourceManager resourceManager, @Nonnull Predicate<IResourceType> resourcePredicate)
-    {
-        if (resourcePredicate.test(VanillaResourceType.TEXTURES))
-        {
+    public void onResourceManagerReload(@Nonnull IResourceManager resourceManager, @Nonnull Predicate<IResourceType> resourcePredicate) {
+        if (resourcePredicate.test(VanillaResourceType.TEXTURES)) {
             reloadTextures();
         }
     }

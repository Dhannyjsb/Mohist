--- ../src-base/minecraft/net/minecraft/world/World.java
+++ ../src-work/minecraft/net/minecraft/world/World.java
@@ -3,21 +3,14 @@
 import com.google.common.base.Function;
 import com.google.common.base.MoreObjects;
 import com.google.common.base.Predicate;
+import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Lists;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.UUID;
-import java.util.function.Supplier;
-
-import javax.annotation.Nullable;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import net.minecraft.advancements.AdvancementManager;
 import net.minecraft.advancements.FunctionManager;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockLiquid;
-import net.minecraft.block.BlockObserver;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.crash.CrashReport;
@@ -25,12 +18,22 @@
 import net.minecraft.crash.ICrashReportDetail;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.item.EntityItem;
+import net.minecraft.entity.item.EntityXPOrb;
+import net.minecraft.entity.monster.EntityGhast;
+import net.minecraft.entity.monster.EntityGolem;
+import net.minecraft.entity.monster.EntityMob;
+import net.minecraft.entity.monster.EntitySlime;
+import net.minecraft.entity.passive.EntityAnimal;
+import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Biomes;
 import net.minecraft.init.Blocks;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.network.Packet;
+import net.minecraft.network.play.server.SPacketWorldBorder;
 import net.minecraft.pathfinding.PathWorldListener;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.scoreboard.Scoreboard;
@@ -44,26 +47,56 @@
 import net.minecraft.util.ReportedException;
 import net.minecraft.util.SoundCategory;
 import net.minecraft.util.SoundEvent;
-import net.minecraft.util.math.AxisAlignedBB;
-import net.minecraft.util.math.BlockPos;
-import net.minecraft.util.math.MathHelper;
-import net.minecraft.util.math.RayTraceResult;
-import net.minecraft.util.math.Vec3d;
+import net.minecraft.util.math.*;
 import net.minecraft.village.VillageCollection;
 import net.minecraft.world.biome.Biome;
 import net.minecraft.world.biome.BiomeProvider;
+import net.minecraft.world.border.IBorderListener;
 import net.minecraft.world.border.WorldBorder;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
+import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.structure.StructureBoundingBox;
 import net.minecraft.world.storage.ISaveHandler;
+import net.minecraft.world.storage.MapData;
 import net.minecraft.world.storage.MapStorage;
 import net.minecraft.world.storage.WorldInfo;
 import net.minecraft.world.storage.WorldSavedData;
 import net.minecraft.world.storage.loot.LootTableManager;
+import net.minecraftforge.cauldron.CauldronHooks;
+import net.minecraftforge.common.DimensionManager;
+import net.minecraftforge.common.ForgeChunkManager;
 import net.minecraftforge.fml.relauncher.Side;
 import net.minecraftforge.fml.relauncher.SideOnly;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.v1_12_R1.CraftServer;
+import org.bukkit.craftbukkit.v1_12_R1.CraftWorld;
+import org.bukkit.craftbukkit.v1_12_R1.event.CraftEventFactory;
+import org.bukkit.craftbukkit.v1_12_R1.util.CraftMagicNumbers;
+import org.bukkit.entity.NPC;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.generator.ChunkGenerator;
+import red.mohist.Mohist;
+import red.mohist.api.ServerAPI;
+import red.mohist.configuration.EntityWorldConfig;
+import red.mohist.configuration.TileEntityConfig;
+import red.mohist.configuration.TileEntityWorldConfig;
+import red.mohist.util.ThermiteRandom;
 
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Random;
+import java.util.UUID;
+
 public abstract class World implements IBlockAccess, net.minecraftforge.common.capabilities.ICapabilityProvider
 {
     /**
@@ -77,41 +110,41 @@
     protected boolean scheduledUpdatesAreImmediate;
     public final List<Entity> loadedEntityList = Lists.<Entity>newArrayList();
     protected final List<Entity> unloadedEntityList = Lists.<Entity>newArrayList();
-    public final List<TileEntity> loadedTileEntityList = Lists.<TileEntity>newArrayList();
+    public List<TileEntity> loadedTileEntityList = Lists.<TileEntity>newArrayList();
     public final List<TileEntity> tickableTileEntities = Lists.<TileEntity>newArrayList();
-    private final List<TileEntity> addedTileEntityList = Lists.<TileEntity>newArrayList();
+    private final Queue<TileEntity> addedTileEntityList = Queues.newConcurrentLinkedQueue();
     private final List<TileEntity> tileEntitiesToBeRemoved = Lists.<TileEntity>newArrayList();
-    public final List<EntityPlayer> playerEntities = Lists.<EntityPlayer>newArrayList();
+    public final Queue<EntityPlayer> playerEntities = Queues.newConcurrentLinkedQueue();
     public final List<Entity> weatherEffects = Lists.<Entity>newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap<Entity>();
+    protected final Map<Integer,Entity> entitiesById = Maps.newConcurrentMap();//hose
     private final long cloudColour = 16777215L;
     private int skylightSubtracted;
-    protected int updateLCG = (new Random()).nextInt();
     protected final int DIST_HASH_MAGIC = 1013904223;
     public float prevRainingStrength;
     public float rainingStrength;
     public float prevThunderingStrength;
     public float thunderingStrength;
     private int lastLightningBolt;
-    public final Random rand = new Random();
-    public final WorldProvider provider;
+    public final Random rand = new ThermiteRandom();
+    protected int updateLCG = this.rand.nextInt();
+    public WorldProvider provider;
     protected PathWorldListener pathListener = new PathWorldListener();
     protected List<IWorldEventListener> eventListeners;
     protected IChunkProvider chunkProvider;
     protected final ISaveHandler saveHandler;
-    protected WorldInfo worldInfo;
+    public WorldInfo worldInfo;
     protected boolean findingSpawnPoint;
-    protected MapStorage mapStorage;
+    public MapStorage mapStorage;
     public VillageCollection villageCollection;
     protected LootTableManager lootTable;
     protected AdvancementManager advancementManager;
     protected FunctionManager functionManager;
     public final Profiler profiler;
     private final Calendar calendar;
-    protected Scoreboard worldScoreboard;
+    public Scoreboard worldScoreboard;
     public final boolean isRemote;
-    protected boolean spawnHostileMobs;
-    protected boolean spawnPeacefulMobs;
+    public boolean spawnHostileMobs;
+    public boolean spawnPeacefulMobs;
     private boolean processingLoadedTiles;
     private final WorldBorder worldBorder;
     int[] lightUpdateBlockList;
@@ -122,8 +155,132 @@
     private net.minecraftforge.common.capabilities.CapabilityDispatcher capabilities;
     private net.minecraftforge.common.util.WorldCapabilityData capabilityData;
 
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+    public boolean captureTreeGeneration = false;
+    public List<EntityItem> captureDrops;
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    private int tickPosition;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+    private boolean guardEntityList; // Spigot
+    public EntityWorldConfig entityWorldConfig;
+    public TileEntityWorldConfig tileEntityWorldConfig;
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<>(); // Paper - Optimize explosions
+    private ImmutableSetMultimap<ChunkPos,ForgeChunkManager.Ticket> forcedChunks = ImmutableSetMultimap.of();
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( info.getWorldName() ); // Spigot
+        this.tileEntityWorldConfig = new TileEntityWorldConfig(info.getWorldName(), MinecraftServer.tileEntityConfig);
+        this.entityWorldConfig = new EntityWorldConfig(info.getWorldName(), MinecraftServer.entityConfig);
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
+        this.eventListeners = Lists.newArrayList(this.pathListener);
+        this.calendar = Calendar.getInstance();
+        this.worldScoreboard = new Scoreboard();
+        this.spawnHostileMobs = true;
+        this.spawnPeacefulMobs = true;
+        this.lightUpdateBlockList = new int[32768];
+        this.saveHandler = saveHandlerIn;
+        this.profiler = profilerIn;
+        this.worldInfo = info;
+        this.provider = providerIn;
+        this.isRemote = client;
+        this.worldBorder = providerIn.createWorldBorder();
+        perWorldStorage = new MapStorage((ISaveHandler)null);
+        // Mohist start
+        if (DimensionManager.getWorld(0) != null) // if overworld has loaded, use its mapstorage
+        {
+            this.mapStorage = DimensionManager.getWorld(0).mapStorage;
+        }
+        else
+        {
+            this.mapStorage = new MapStorage(saveHandlerIn);
+        }
+
+        if(this.worldInfo != null) // Use saved dimension from level.dat. Fixes issues with MultiVerse
+        {
+            if (this.worldInfo.getDimension() != 0)
+                this.provider.setDimension(this.worldInfo.getDimension());
+            else
+            {
+                this.worldInfo.setDimension(this.provider.getDimension());
+            }
+        }
+
+        if (this.worldInfo.getDimension() == 0)
+        {
+            generator = this.getServer().getGenerator(this.worldInfo.getWorldName());
+            if (generator != null) {
+                getWorld().setGenerator(generator);
+                getWorld().getPopulators().addAll(generator.getDefaultPopulators(getWorld()));
+            }
+        }
+        // Mohist end
+        // CraftBukkit start
+        getWorldBorder().world = (WorldServer) this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().addListener(new IBorderListener() {
+            public void onSizeChanged(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_SIZE), worldborder.world);
+            }
+
+            public void onTransitionStarted(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.LERP_SIZE), worldborder.world);
+            }
+
+            public void onCenterChanged(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_CENTER), worldborder.world);
+            }
+
+            public void onWarningTimeChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_WARNING_TIME), worldborder.world);
+            }
+
+            public void onWarningDistanceChanged(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new SPacketWorldBorder(worldborder, SPacketWorldBorder.Action.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void onDamageAmountChanged(WorldBorder worldborder, double d0) {}
+
+            public void onDamageBufferChanged(WorldBorder worldborder, double d0) {}
+        });
+        this.getServer().addWorld(this.world);
+        // CraftBukkit end
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+    }
+
+
     protected World(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
     {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( info.getWorldName() ); // Spigot
+        this.tileEntityWorldConfig = new TileEntityWorldConfig(info.getWorldName(), MinecraftServer.tileEntityConfig);
+        this.entityWorldConfig = new EntityWorldConfig(info.getWorldName(), MinecraftServer.entityConfig);
+        this.world = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).getWorld() : null;
         this.eventListeners = Lists.newArrayList(this.pathListener);
         this.calendar = Calendar.getInstance();
         this.worldScoreboard = new Scoreboard();
@@ -136,7 +293,10 @@
         this.provider = providerIn;
         this.isRemote = client;
         this.worldBorder = providerIn.createWorldBorder();
-        perWorldStorage = new MapStorage((ISaveHandler)null);
+        perWorldStorage = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).mapStorage : new MapStorage(null);
+        this.mapStorage = DimensionManager.getWorld(0) != null ? DimensionManager.getWorld(0).mapStorage : new MapStorage(null);
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
     }
 
     public World init()
@@ -298,7 +458,7 @@
         }
     }
 
-    protected abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
+    public abstract boolean isChunkLoaded(int x, int z, boolean allowEmpty);
 
     public Chunk getChunkFromBlockCoords(BlockPos pos)
     {
@@ -317,6 +477,26 @@
 
     public boolean setBlockState(BlockPos pos, IBlockState newState, int flags)
     {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration && Bukkit.isPrimaryThread()) {
+            net.minecraftforge.common.util.BlockSnapshot blocksnapshot = null;
+
+            for (net.minecraftforge.common.util.BlockSnapshot previous : this.capturedBlockSnapshots)
+            {
+                if (previous.getPos().equals(pos))
+                {
+                    blocksnapshot = previous;
+                    break;
+                }
+            }
+            if (blocksnapshot != null)
+            {
+                this.capturedBlockSnapshots.remove(blocksnapshot);
+            }
+            this.capturedBlockSnapshots.add(new net.minecraftforge.common.util.BlockSnapshot(this, pos, newState, flags));
+            return true;
+        }
+        // CraftBukkit end
         if (this.isOutsideBuildHeight(pos))
         {
             return false;
@@ -437,6 +617,11 @@
     {
         if (this.worldInfo.getTerrainType() != WorldType.DEBUG_ALL_BLOCK_STATES)
         {
+ 			// CraftBukkit start
+            if (populating) {
+                return;
+            }
+			// CraftBukkit end
             this.notifyNeighborsOfStateChange(pos, blockType, p_175722_3_);
         }
     }
@@ -488,7 +673,6 @@
     {
         if(net.minecraftforge.event.ForgeEventFactory.onNeighborNotify(this, pos, this.getBlockState(pos), java.util.EnumSet.allOf(EnumFacing.class), updateObservers).isCanceled())
             return;
-
         this.neighborChanged(pos.west(), blockType, pos);
         this.neighborChanged(pos.east(), blockType, pos);
         this.neighborChanged(pos.down(), blockType, pos);
@@ -548,6 +732,15 @@
 
             try
             {
+                CraftWorld world =  ((WorldServer) this).getWorld();
+                if (world != null) {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
                 iblockstate.neighborChanged(this, pos, blockIn, fromPos);
             }
             catch (Throwable throwable)
@@ -586,6 +779,11 @@
                 {
                     iblockstate.getBlock().observedNeighborChange(iblockstate, this, pos, p_190529_2_, p_190529_3_);
                 }
+                catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                    haveWeSilencedAPhysicsCrash = true;
+                    blockLocation = pos.getX() + ", " + pos.getY() + ", " + pos.getZ();
+                    // Spigot End
+                }
                 catch (Throwable throwable)
                 {
                     CrashReport crashreport = CrashReport.makeCrashReport(throwable, "Exception while updating neighbours");
@@ -596,7 +794,7 @@
                         {
                             try
                             {
-                                return String.format("ID #%d (%s // %s // %s)", Block.getIdFromBlock(p_190529_2_), p_190529_2_.getUnlocalizedName(), p_190529_2_.getClass().getName(), p_190529_2_.getRegistryName());
+                                return String.format("ID #%d (%s // %s)", Block.getIdFromBlock(p_190529_2_), p_190529_2_.getUnlocalizedName(), p_190529_2_.getClass().getCanonicalName());
                             }
                             catch (Throwable var2)
                             {
@@ -664,11 +862,45 @@
             {
                 pos = new BlockPos(pos.getX(), 255, pos.getZ());
             }
-
             return this.getChunkFromBlockCoords(pos).getLightSubtracted(pos, 0);
         }
     }
 
+    // Paper start - test if meets light level, return faster
+    // logic copied from below
+    public boolean isLightLevel(BlockPos blockposition, int level) {
+        if (blockposition.isValidLocation()) {
+            if (this.getBlockState(blockposition).useNeighborBrightness()) {
+                if (this.getLight(blockposition.up(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.east(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.west(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.south(), false) >= level) {
+                    return true;
+                }
+                if (this.getLight(blockposition.north(), false) >= level) {
+                    return true;
+                }
+                return false;
+            } else {
+                if (blockposition.getY() >= 256) {
+                    blockposition = new BlockPos(blockposition.getX(), 255, blockposition.getZ());
+                }
+
+                Chunk chunk = this.getChunkFromBlockCoords(blockposition);
+                return chunk.getLightSubtracted(blockposition, this.getSkylightSubtracted()) >= level;
+            }
+        } else {
+            return true;
+        }
+    }
+    // Paper end
+
     public int getLightFromNeighbors(BlockPos pos)
     {
         return this.getLight(pos, true);
@@ -793,7 +1025,7 @@
             }
 
             if (!this.isValid(pos))
-            {
+			{
                 return type.defaultLightValue;
             }
             else if (!this.isBlockLoaded(pos))
@@ -846,7 +1078,7 @@
         }
 
         if (!this.isValid(pos))
-        {
+		{
             return type.defaultLightValue;
         }
         else if (!this.isBlockLoaded(pos))
@@ -863,7 +1095,7 @@
     public void setLightFor(EnumSkyBlock type, BlockPos pos, int lightValue)
     {
         if (this.isValid(pos))
-        {
+		{
             if (this.isBlockLoaded(pos))
             {
                 Chunk chunk = this.getChunkFromBlockCoords(pos);
@@ -902,6 +1134,17 @@
 
     public IBlockState getBlockState(BlockPos pos)
     {
+		// CraftBukkit start - tree generation
+        if (captureTreeGeneration)
+		{
+            for (net.minecraftforge.common.util.BlockSnapshot blocksnapshot : this.capturedBlockSnapshots)
+            {
+                if (blocksnapshot.getPos().equals(pos)) { 
+                    return blocksnapshot.getReplacedBlock();
+				}
+            }
+        }
+        // CraftBukkit end
         if (this.isOutsideBuildHeight(pos))
         {
             return Blocks.AIR.getDefaultState();
@@ -1178,14 +1421,66 @@
 
     public boolean spawnEntity(Entity entityIn)
     {
+        // CraftBukkit start - Used for entities other than creatures
+        return addEntity(entityIn, CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public boolean addEntity(Entity entity, CreatureSpawnEvent.SpawnReason spawnReason) {
+        if (entity == null) return false;
+        org.bukkit.event.Cancellable event = null;
+        if (entity instanceof EntityLivingBase && !(entity instanceof EntityPlayerMP)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterMob || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMob || entity instanceof EntityGhast || entity instanceof EntitySlime;
+            boolean isNpc = entity instanceof NPC;
+
+            if (spawnReason != CreatureSpawnEvent.SpawnReason.CUSTOM) {
+                if (isAnimal && !spawnPeacefulMobs || isMonster && !spawnHostileMobs || isNpc && !getServer().getServer().getCanSpawnNPCs()) {
+                    entity.isDead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLivingBase) entity, spawnReason);
+        } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Vehicle){
+            event = CraftEventFactory.callVehicleCreateEvent(entity);
+        }
+
+        // Spigot start
+        else if (entity instanceof EntityXPOrb) {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.getEntityBoundingBox().grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityXPOrb) {
+                        EntityXPOrb loopItem = (EntityXPOrb) e;
+                        if (!loopItem.isDead) {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.isDead)) {
+            entity.isDead = true;
+            return false;
+        }
+        // CraftBukkit end
         // do not drop any items while restoring blocksnapshots. Prevents dupes
-        if (!this.isRemote && (entityIn == null || (entityIn instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
+        if (!this.isRemote && (entity == null || (entity instanceof net.minecraft.entity.item.EntityItem && this.restoringBlockSnapshots))) return false;
 
-        int i = MathHelper.floor(entityIn.posX / 16.0D);
-        int j = MathHelper.floor(entityIn.posZ / 16.0D);
-        boolean flag = entityIn.forceSpawn;
+        int i = MathHelper.floor(entity.posX / 16.0D);
+        int j = MathHelper.floor(entity.posZ / 16.0D);
+        boolean flag = entity.forceSpawn;
 
-        if (entityIn instanceof EntityPlayer)
+        if (entity instanceof EntityPlayer)
         {
             flag = true;
         }
@@ -1196,18 +1491,19 @@
         }
         else
         {
-            if (entityIn instanceof EntityPlayer)
+            if (entity instanceof EntityPlayer)
             {
-                EntityPlayer entityplayer = (EntityPlayer)entityIn;
+                EntityPlayer entityplayer = (EntityPlayer)entity;
                 this.playerEntities.add(entityplayer);
                 this.updateAllPlayersSleepingFlag();
             }
 
-            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entityIn, this)) && !flag) return false;
+            if (net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity, this)) && !flag) return false;
 
-            this.getChunkFromChunkCoords(i, j).addEntity(entityIn);
-            this.loadedEntityList.add(entityIn);
-            this.onEntityAdded(entityIn);
+            this.getChunkFromChunkCoords(i, j).addEntity(entity);
+            if (entity.isDead) return false; // Paper - don't add dead entities, chunk registration may of killed it
+            this.loadedEntityList.add(entity);
+            this.onEntityAdded(entity);
             return true;
         }
     }
@@ -1216,18 +1512,22 @@
     {
         for (int i = 0; i < this.eventListeners.size(); ++i)
         {
-            ((IWorldEventListener)this.eventListeners.get(i)).onEntityAdded(entityIn);
+           ((IWorldEventListener)this.eventListeners.get(i)).onEntityAdded(entityIn);
         }
         entityIn.onAddedToWorld();
+        entityIn.valid = true; // CraftBukkit
+        new com.destroystokyo.paper.event.entity.EntityAddToWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
     }
 
     public void onEntityRemoved(Entity entityIn)
     {
         for (int i = 0; i < this.eventListeners.size(); ++i)
         {
-            ((IWorldEventListener)this.eventListeners.get(i)).onEntityRemoved(entityIn);
+            ((IWorldEventListener) this.eventListeners.get(i)).onEntityRemoved(entityIn);
         }
         entityIn.onRemovedFromWorld();
+        new com.destroystokyo.paper.event.entity.EntityRemoveFromWorldEvent(entityIn.getBukkitEntity()).callEvent(); // Paper - fire while valid
+        entityIn.valid = false; // CraftBukkit
     }
 
     public void removeEntity(Entity entityIn)
@@ -1247,31 +1547,46 @@
         if (entityIn instanceof EntityPlayer)
         {
             this.playerEntities.remove(entityIn);
+            // Spigot start
+            for ( Object o : mapStorage.loadedDataList )
+            {
+                if ( o instanceof MapData )
+                {
+                    MapData map = (MapData) o;
+                    map.playersHashMap.remove( entityIn );
+                    for ( Iterator<MapData.MapInfo> iter = (Iterator<MapData.MapInfo>) map.playersArrayList.iterator(); iter.hasNext(); )
+                    {
+                        if ( iter.next().player == entityIn )
+                        {
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+            // Spigot end
             this.updateAllPlayersSleepingFlag();
             this.onEntityRemoved(entityIn);
         }
     }
 
-    public void removeEntityDangerously(Entity entityIn)
-    {
+    public void removeEntityDangerously(Entity entityIn) {
         entityIn.setDropItemsWhenDead(false);
         entityIn.setDead();
 
-        if (entityIn instanceof EntityPlayer)
-        {
+        if (entityIn instanceof EntityPlayer) {
             this.playerEntities.remove(entityIn);
             this.updateAllPlayersSleepingFlag();
         }
 
-        int i = entityIn.chunkCoordX;
-        int j = entityIn.chunkCoordZ;
+        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+            int i = entityIn.chunkCoordX;
+            int j = entityIn.chunkCoordZ;
 
-        if (entityIn.addedToChunk && this.isChunkLoaded(i, j, true))
-        {
-            this.getChunkFromChunkCoords(i, j).removeEntity(entityIn);
-        }
-
-        this.loadedEntityList.remove(entityIn);
+            if (entityIn.addedToChunk && this.isChunkLoaded(i, j, true)) {
+                this.getChunkFromChunkCoords(i, j).removeEntity(entityIn);
+            }
+            this.loadedEntityList.remove(entityIn);
+        } // Spigot
         this.onEntityRemoved(entityIn);
     }
 
@@ -1674,7 +1989,11 @@
         for (int i = 0; i < this.weatherEffects.size(); ++i)
         {
             Entity entity = this.weatherEffects.get(i);
-
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
             try
             {
                 if(entity.updateBlocked) continue;
@@ -1697,7 +2016,7 @@
 
                 if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
                 {
-                    net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport.getCompleteReport());
+                    Mohist.LOGGER.fatal("{}", crashreport.getCompleteReport());
                     removeEntity(entity);
                 }
                 else
@@ -1711,17 +2030,24 @@
         }
 
         this.profiler.endStartSection("remove");
-        this.loadedEntityList.removeAll(this.unloadedEntityList);
+        //this.loadedEntityList.removeAll(this.unloadedEntityList);
+        // Paper start - Use alternate implementation with faster contains
+        java.util.Set<Entity> toRemove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
+        toRemove.addAll(this.unloadedEntityList);
+        this.loadedEntityList.removeAll(toRemove);
+        // Paper end
 
-        for (int k = 0; k < this.unloadedEntityList.size(); ++k)
-        {
-            Entity entity1 = this.unloadedEntityList.get(k);
-            int j = entity1.chunkCoordX;
-            int k1 = entity1.chunkCoordZ;
+        for (int k = 0; k < this.unloadedEntityList.size(); ++k) {
+            try {
+                Entity entity1 = this.unloadedEntityList.get(k);
+                int j = entity1.chunkCoordX;
+                int k1 = entity1.chunkCoordZ;
 
-            if (entity1.addedToChunk && this.isChunkLoaded(j, k1, true))
-            {
-                this.getChunkFromChunkCoords(j, k1).removeEntity(entity1);
+                if (entity1.addedToChunk && this.isChunkLoaded(j, k1, true)) {
+                    this.getChunkFromChunkCoords(j, k1).removeEntity(entity1);
+                }
+            } catch (Exception ex) {
+
             }
         }
 
@@ -1734,66 +2060,73 @@
         this.tickPlayers();
         this.profiler.endStartSection("regular");
 
-        for (int i1 = 0; i1 < this.loadedEntityList.size(); ++i1)
-        {
-            Entity entity2 = this.loadedEntityList.get(i1);
-            Entity entity3 = entity2.getRidingEntity();
-
-            if (entity3 != null)
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        guardEntityList = true; // Spigot
+        int entitiesThisCycle = 0;
+        if (tickPosition < 0) tickPosition = 0;
+        entityLimiter.initTick();//hose
+        loadedEntityList.parallelStream().forEach(ent -> {//hose
+            if (!entityLimiter.shouldContinue()) {
+                return;
+            }
+            Entity entity1 = ent.getRidingEntity();
+            if (entity1 != null)
             {
-                if (!entity3.isDead && entity3.isPassenger(entity2))
+                if (!entity1.isDead && entity1.isPassenger(ent))
                 {
-                    continue;
+                    return;
                 }
 
-                entity2.dismountRidingEntity();
+                ent.dismountRidingEntity();
             }
 
             this.profiler.startSection("tick");
 
-            if (!entity2.isDead && !(entity2 instanceof EntityPlayerMP))
+            if (!ent.isDead && !(ent instanceof EntityPlayerMP))
             {
                 try
                 {
-                    net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(entity2);
-                    this.updateEntity(entity2);
-                    net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(entity2);
+                    net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackStart(ent);
+                    this.updateEntity(ent);
+                    net.minecraftforge.server.timings.TimeTracker.ENTITY_UPDATE.trackEnd(ent);
                 }
                 catch (Throwable throwable1)
                 {
                     CrashReport crashreport1 = CrashReport.makeCrashReport(throwable1, "Ticking entity");
                     CrashReportCategory crashreportcategory1 = crashreport1.makeCategory("Entity being ticked");
-                    entity2.addEntityCrashInfo(crashreportcategory1);
+                    ent.addEntityCrashInfo(crashreportcategory1);
                     if (net.minecraftforge.common.ForgeModContainer.removeErroringEntities)
                     {
-                        net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport1.getCompleteReport());
-                        removeEntity(entity2);
+                        Mohist.LOGGER.fatal("{}", crashreport1.getCompleteReport());
+                        removeEntity(ent);
                     }
                     else
                     throw new ReportedException(crashreport1);
+
                 }
             }
 
             this.profiler.endSection();
             this.profiler.startSection("remove");
 
-            if (entity2.isDead)
+            if (ent.isDead)
             {
-                int l1 = entity2.chunkCoordX;
-                int i2 = entity2.chunkCoordZ;
+                int l1 = ent.chunkCoordX;
+                int i2 = ent.chunkCoordZ;
 
-                if (entity2.addedToChunk && this.isChunkLoaded(l1, i2, true))
+                if (ent.addedToChunk && this.isChunkLoaded(l1, i2, true))
                 {
-                    this.getChunkFromChunkCoords(l1, i2).removeEntity(entity2);
+                    this.getChunkFromChunkCoords(l1, i2).removeEntity(ent);
                 }
-
-                this.loadedEntityList.remove(i1--);
-                this.onEntityRemoved(entity2);
+                this.loadedEntityList.remove(ent); // CraftBukkit - Use field for loop variable
+                this.onEntityRemoved(ent);
             }
 
             this.profiler.endSection();
-        }
+        });
 
+        guardEntityList = false; // Spigot
+
         this.profiler.endStartSection("blockEntities");
 
         this.processingLoadedTiles = true; //FML Move above remove to prevent CMEs
@@ -1802,27 +2135,47 @@
         {
             for (Object tile : tileEntitiesToBeRemoved)
             {
-               ((TileEntity)tile).onChunkUnload();
+                TileEntity te = (TileEntity)tile;
+                try { te.setGC(true); } catch (Exception e) {}
+                te.onChunkUnload();
             }
+            List temporary_tile_entity_list = new ArrayList(this.loadedTileEntityList.size());
+            for(Object tile : loadedTileEntityList)
+            {
+                boolean marker = false;
+                try { marker = !((TileEntity)tile).isGC(); } catch (Exception e) { try { marker = this.tileEntitiesToBeRemoved.contains(tile); } catch (Exception ex) { marker = false; } }
+                if (marker) { temporary_tile_entity_list.add(tile); }
+            }
+            this.loadedTileEntityList = temporary_tile_entity_list;
+            for (Object tile : tileEntitiesToBeRemoved)
+            {
+                TileEntity te = (TileEntity)tile;
+                try { te.setGC(false); } catch (Exception e) { }
+            }
 
             // forge: faster "contains" makes this removal much more efficient
             java.util.Set<TileEntity> remove = java.util.Collections.newSetFromMap(new java.util.IdentityHashMap<>());
             remove.addAll(tileEntitiesToBeRemoved);
             this.tickableTileEntities.removeAll(remove);
-            this.loadedTileEntityList.removeAll(remove);
             this.tileEntitiesToBeRemoved.clear();
         }
 
-        Iterator<TileEntity> iterator = this.tickableTileEntities.iterator();
-
-        while (iterator.hasNext())
-        {
-            TileEntity tileentity = iterator.next();
-
+        int tilesThisCycle = 0;
+        for (tileLimiter.initTick();
+             tilesThisCycle < this.tickableTileEntities.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+             tileTickPosition++, tilesThisCycle++) {
+            tileTickPosition = (tileTickPosition < tickableTileEntities.size()) ? tileTickPosition : 0;
+            TileEntity tileentity = (TileEntity) this.tickableTileEntities.get(tileTickPosition);
+            // Spigot start
+            if (tileentity == null) {
+                tilesThisCycle--;
+                this.tickableTileEntities.remove(tileTickPosition--);
+                continue;
+            }
+            // Spigot end
             if (!tileentity.isInvalid() && tileentity.hasWorld())
             {
                 BlockPos blockpos = tileentity.getPos();
-
                 if (this.isBlockLoaded(blockpos, false) && this.worldBorder.contains(blockpos)) //Forge: Fix TE's getting an extra tick on the client side....
                 {
                     try
@@ -1843,26 +2196,26 @@
                         tileentity.addInfoToCrashReport(crashreportcategory2);
                         if (net.minecraftforge.common.ForgeModContainer.removeErroringTileEntities)
                         {
-                            net.minecraftforge.fml.common.FMLLog.log.fatal("{}", crashreport2.getCompleteReport());
+						    Mohist.LOGGER.fatal("{}", crashreport2.getCompleteReport());
                             tileentity.invalidate();
                             this.removeTileEntity(tileentity.getPos());
                         }
                         else
                         throw new ReportedException(crashreport2);
-                    }
+                    }                
                 }
             }
 
             if (tileentity.isInvalid())
             {
-                iterator.remove();
-                this.loadedTileEntityList.remove(tileentity);
+                tilesThisCycle--;
+                this.tickableTileEntities.remove(tileTickPosition--);
 
                 if (this.isBlockLoaded(tileentity.getPos()))
                 {
                     //Forge: Bugfix: If we set the tile entity it immediately sets it in the chunk, so we could be desyned
                     Chunk chunk = this.getChunkFromBlockCoords(tileentity.getPos());
-                    if (chunk.getTileEntity(tileentity.getPos(), net.minecraft.world.chunk.Chunk.EnumCreateEntityType.CHECK) == tileentity)
+                    if (chunk.getTileEntity(tileentity.getPos(), Chunk.EnumCreateEntityType.CHECK) == tileentity)
                         chunk.removeTileEntity(tileentity.getPos());
                 }
             }
@@ -1873,26 +2226,17 @@
 
         if (!this.addedTileEntityList.isEmpty())
         {
-            for (int j1 = 0; j1 < this.addedTileEntityList.size(); ++j1)
-            {
-                TileEntity tileentity1 = this.addedTileEntityList.get(j1);
-
-                if (!tileentity1.isInvalid())
-                {
-                    if (!this.loadedTileEntityList.contains(tileentity1))
-                    {
-                        this.addTileEntity(tileentity1);
-                    }
-
-                    if (this.isBlockLoaded(tileentity1.getPos()))
-                    {
-                        Chunk chunk = this.getChunkFromBlockCoords(tileentity1.getPos());
-                        IBlockState iblockstate = chunk.getBlockState(tileentity1.getPos());
-                        chunk.addTileEntity(tileentity1.getPos(), tileentity1);
-                        this.notifyBlockUpdate(tileentity1.getPos(), iblockstate, iblockstate, 3);
-                    }
+            this.addedTileEntityList.stream().filter(tileentity1 -> !tileentity1.isInvalid()).filter(tileentity1 -> this.isBlockLoaded(tileentity1.getPos())).forEach(tileentity1 -> {
+                Chunk chunk = this.getChunkFromBlockCoords(tileentity1.getPos());
+                IBlockState iblockdata = chunk.getBlockState(tileentity1.getPos());
+                chunk.addTileEntity(tileentity1.getPos(), tileentity1);
+                this.notifyBlockUpdate(tileentity1.getPos(), iblockdata, iblockdata, 3);
+                // CraftBukkit start
+                if (!this.loadedTileEntityList.contains(tileentity1)) {
+                    this.addTileEntity(tileentity1);
                 }
-            }
+                // CraftBukkit end
+            });
 
             this.addedTileEntityList.clear();
         }
@@ -1912,9 +2256,9 @@
         // Forge: wait to add new TE if we're currently processing existing ones
         if (processingLoadedTiles) return addedTileEntityList.add(tile);
 
-        boolean flag = this.loadedTileEntityList.add(tile);
+        boolean flag = true;
 
-        if (flag && tile instanceof ITickable)
+        if (flag && tile instanceof ITickable && !this.tickableTileEntities.contains(tile))
         {
             this.tickableTileEntities.add(tile);
         }
@@ -1957,20 +2301,38 @@
 
     public void updateEntityWithOptionalForce(Entity entityIn, boolean forceUpdate)
     {
+        if (entityIn.isDead) {
+            return;
+        }
         if (!(entityIn instanceof EntityPlayer))
         {
             int j2 = MathHelper.floor(entityIn.posX);
             int k2 = MathHelper.floor(entityIn.posZ);
-
-            boolean isForced = getPersistentChunks().containsKey(new net.minecraft.util.math.ChunkPos(j2 >> 4, k2 >> 4));
-            int range = isForced ? 0 : 32;
-            boolean canUpdate = !forceUpdate || this.isAreaLoaded(j2 - range, 0, k2 - range, j2 + range, 0, k2 + range, true);
+            ChunkPos cp = new ChunkPos(j2 >> 4, k2 >> 4);
+            boolean isForced = getPersistentChunks().containsKey(cp);
+            Chunk startingChunk = this.getChunkIfLoaded(j2 >> 4, k2 >> 4);
+            boolean canUpdate = !forceUpdate || (startingChunk != null && (isForced || startingChunk.areNeighborsLoaded(2)));
             if (!canUpdate) canUpdate = net.minecraftforge.event.ForgeEventFactory.canEntityUpdate(entityIn);
 
             if (!canUpdate)
             {
                 return;
             }
+            // Spigot start
+            byte tickAbility = CauldronHooks.canEntityTick(entityIn,this);
+            if (!isForced && !canUpdate && (tickAbility == -1 || (!org.spigotmc.ActivationRange.checkIfActive(entityIn) && tickAbility != 1)))
+            {
+                entityIn.ticksExisted++;
+                entityIn.inactiveTick();
+                return;
+            }
+            else if(tickAbility == -1)
+            {
+                entityIn.ticksExisted++;
+                entityIn.inactiveTick();
+                return;
+            }
+            // Spigot end
         }
 
         entityIn.lastTickPosX = entityIn.posX;
@@ -1991,6 +2353,7 @@
             {
                 if(!entityIn.updateBlocked)
                 entityIn.onUpdate();
+                entityIn.postTick();
             }
         }
 
@@ -2046,17 +2409,13 @@
 
         if (forceUpdate && entityIn.addedToChunk)
         {
-            for (Entity entity4 : entityIn.getPassengers())
-            {
-                if (!entity4.isDead && entity4.getRidingEntity() == entityIn)
-                {
-                    this.updateEntity(entity4);
+            entityIn.getPassengers().forEach(entity1 -> {//hose
+                if (!entity1.isDead && entity1.getRidingEntity() == entityIn) {
+                    this.updateEntity(entity1);
+                } else {
+                    entity1.dismountRidingEntity();
                 }
-                else
-                {
-                    entity4.dismountRidingEntity();
-                }
-            }
+            });
         }
     }
 
@@ -2382,25 +2741,25 @@
     public TileEntity getTileEntity(BlockPos pos)
     {
         if (this.isOutsideBuildHeight(pos))
-        {
+		{
             return null;
         }
-        else
-        {
+		else
+		{
             TileEntity tileentity2 = null;
 
             if (this.processingLoadedTiles)
-            {
+			{
                 tileentity2 = this.getPendingTileEntityAt(pos);
             }
 
             if (tileentity2 == null)
-            {
+			{
                 tileentity2 = this.getChunkFromBlockCoords(pos).getTileEntity(pos, Chunk.EnumCreateEntityType.IMMEDIATE);
             }
 
             if (tileentity2 == null)
-            {
+			{
                 tileentity2 = this.getPendingTileEntityAt(pos);
             }
 
@@ -2411,13 +2770,9 @@
     @Nullable
     private TileEntity getPendingTileEntityAt(BlockPos pos)
     {
-        for (int j2 = 0; j2 < this.addedTileEntityList.size(); ++j2)
-        {
-            TileEntity tileentity2 = this.addedTileEntityList.get(j2);
-
-            if (!tileentity2.isInvalid() && tileentity2.getPos().equals(pos))
-            {
-                return tileentity2;
+        for (TileEntity tileentity: this.addedTileEntityList) {
+            if (!tileentity.isInvalid() && tileentity.getPos().equals(pos)) {
+                return tileentity;
             }
         }
 
@@ -2428,7 +2783,7 @@
     {
         pos = pos.toImmutable(); // Forge - prevent mutable BlockPos leaks
         if (!this.isOutsideBuildHeight(pos))
-        {
+		{
             if (tileEntityIn != null && !tileEntityIn.isInvalid())
             {
                 if (this.processingLoadedTiles)
@@ -2451,6 +2806,7 @@
                     }
 
                     toInvalidate.forEach(TileEntity::invalidate);
+                    tileEntityIn.setWorld(this); // Spigot - No null worlds
                     this.addedTileEntityList.add(tileEntityIn);
                 }
                 else
@@ -2502,7 +2858,7 @@
     public boolean isBlockNormalCube(BlockPos pos, boolean _default)
     {
         if (this.isOutsideBuildHeight(pos))
-        {
+		{
             return false;
         }
         else
@@ -2659,6 +3015,7 @@
                 }
 
                 this.rainingStrength = MathHelper.clamp(this.rainingStrength, 0.0F, 1.0F);
+                this.playerEntities.stream().filter(pl -> ((EntityPlayerMP) pl).world == this).forEach(pltw -> ((EntityPlayerMP) pltw).tickWeather());//hose
             }
         }
     }
@@ -2848,8 +3205,11 @@
 
     public boolean checkLightFor(EnumSkyBlock lightType, BlockPos pos)
     {
-        if (!this.isAreaLoaded(pos, 16, false))
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        Chunk chunk = this.getChunkIfLoaded(pos.getX() >> 4, pos.getZ() >> 4);
+        if (chunk == null || !chunk.areNeighborsLoaded(1) /*!this.isAreaLoaded(pos, 16, false)*/)
         {
+            // CraftBukkit end
             return false;
         }
         else
@@ -3010,7 +3370,7 @@
 
     public List<Entity> getEntitiesInAABBexcluding(@Nullable Entity entityIn, AxisAlignedBB boundingBox, @Nullable Predicate <? super Entity > predicate)
     {
-        List<Entity> list = Lists.<Entity>newArrayList();
+        List<Entity> list = new ArrayList(30);
         int j2 = MathHelper.floor((boundingBox.minX - MAX_ENTITY_RADIUS) / 16.0D);
         int k2 = MathHelper.floor((boundingBox.maxX + MAX_ENTITY_RADIUS) / 16.0D);
         int l2 = MathHelper.floor((boundingBox.minZ - MAX_ENTITY_RADIUS) / 16.0D);
@@ -3030,15 +3390,15 @@
         return list;
     }
 
-    public <T extends Entity> List<T> getEntities(Class <? extends T > entityType, Predicate <? super T > filter)
-    {
+    public <T extends Entity> List<T> getEntities(Class<? extends T> entityType, Predicate<? super T> filter)
+	{
         List<T> list = Lists.<T>newArrayList();
 
         for (Entity entity4 : this.loadedEntityList)
-        {
-            if (entityType.isAssignableFrom(entity4.getClass()) && filter.apply((T)entity4))
-            {
-                list.add((T)entity4);
+		{
+            if (entityType.isAssignableFrom(entity4.getClass()) && filter.apply((T) entity4))
+			{
+                list.add((T) entity4);
             }
         }
 
@@ -3071,7 +3431,7 @@
         int k2 = MathHelper.ceil((aabb.maxX + MAX_ENTITY_RADIUS) / 16.0D);
         int l2 = MathHelper.floor((aabb.minZ - MAX_ENTITY_RADIUS) / 16.0D);
         int i3 = MathHelper.ceil((aabb.maxZ + MAX_ENTITY_RADIUS) / 16.0D);
-        List<T> list = Lists.<T>newArrayList();
+        List<T> list = new ArrayList(40);
 
         for (int j3 = j2; j3 < k2; ++j3)
         {
@@ -3116,7 +3476,7 @@
     @Nullable
     public Entity getEntityByID(int id)
     {
-        return this.entitiesById.lookup(id);
+        return this.entitiesById.get(id);
     }
 
     @SideOnly(Side.CLIENT)
@@ -3139,7 +3499,16 @@
 
         for (Entity entity4 : this.loadedEntityList)
         {
-            if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity4 instanceof EntityLiving) {
+                EntityLiving entityinsentient = (EntityLiving) entity4;
+                if (entityinsentient.canDespawn() && entityinsentient.isNoDespawnRequired()) {
+                    continue;
+                }
+            }
+
+            // if ((!(entity4 instanceof EntityLiving) || !((EntityLiving)entity4).isNoDespawnRequired()) && entityType.isAssignableFrom(entity4.getClass()))
+            if (entityType.isAssignableFrom(entity4.getClass()))
             {
                 ++j2;
             }
@@ -3154,6 +3523,9 @@
         {
             if (!net.minecraftforge.common.MinecraftForge.EVENT_BUS.post(new net.minecraftforge.event.entity.EntityJoinWorldEvent(entity4, this)))
             {
+                if (entity4 == null || entity4.isDead || entity4.valid) { // Paper - prevent adding already added or dead entities
+                    continue;
+                }
                 loadedEntityList.add(entity4);
                 this.onEntityAdded(entity4);
             }
@@ -3170,19 +3542,24 @@
         IBlockState iblockstate1 = this.getBlockState(pos);
         AxisAlignedBB axisalignedbb = skipCollisionCheck ? null : blockIn.getDefaultState().getCollisionBoundingBox(this, pos);
 
+        boolean defaultReturn;
         if (!((placer instanceof EntityPlayer) || !net.minecraftforge.event.ForgeEventFactory.onBlockPlace(placer, new net.minecraftforge.common.util.BlockSnapshot(this, pos, blockIn.getDefaultState()), sidePlacedOn).isCanceled())) return false;
         if (axisalignedbb != Block.NULL_AABB && !this.checkNoEntityCollision(axisalignedbb.offset(pos))) // Forge: Remove second parameter, we patch placer to be non-null, passing it here skips collision checks for the placer
         {
-            return false;
+            defaultReturn = false;
         }
         else if (iblockstate1.getMaterial() == Material.CIRCUITS && blockIn == Blocks.ANVIL)
         {
-            return true;
+            defaultReturn = true;
         }
         else
         {
-            return iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
+            defaultReturn = iblockstate1.getBlock().isReplaceable(this, pos) && blockIn.canPlaceBlockOnSide(this, pos, sidePlacedOn);
         }
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()), CraftMagicNumbers.getId(blockIn), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+
+        return event.isBuildable();
     }
 
     public int getSeaLevel()
@@ -3343,10 +3720,11 @@
         double d0 = -1.0D;
         EntityPlayer entityplayer = null;
 
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
-            EntityPlayer entityplayer1 = this.playerEntities.get(j2);
-
+        for (EntityPlayer entityplayer1: this.playerEntities) {//hose
+            if (entityplayer1 == null || entityplayer1.isDead) {
+                continue;
+            }
+            // CraftBukkit end
             if (p_190525_9_.apply(entityplayer1))
             {
                 double d1 = entityplayer1.getDistanceSq(x, y, z);
@@ -3364,22 +3742,7 @@
 
     public boolean isAnyPlayerWithinRangeAt(double x, double y, double z, double range)
     {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
-            EntityPlayer entityplayer = this.playerEntities.get(j2);
-
-            if (EntitySelectors.NOT_SPECTATING.apply(entityplayer))
-            {
-                double d0 = entityplayer.getDistanceSq(x, y, z);
-
-                if (range < 0.0D || d0 < range * range)
-                {
-                    return true;
-                }
-            }
-        }
-
-        return false;
+        return this.playerEntities.stream().filter((entityplayer) -> (EntitySelectors.NOT_SPECTATING.apply(entityplayer))).map((entityplayer) -> entityplayer.getDistanceSq(x, y, z)).anyMatch((d4) -> (range < 0.0D || d4 < range * range));//hose
     }
 
     @Nullable
@@ -3400,10 +3763,7 @@
         double d0 = -1.0D;
         EntityPlayer entityplayer = null;
 
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
-            EntityPlayer entityplayer1 = this.playerEntities.get(j2);
-
+        for (EntityPlayer entityplayer1: this.playerEntities) {//hose
             if (!entityplayer1.capabilities.disableDamage && entityplayer1.isEntityAlive() && !entityplayer1.isSpectator() && (p_184150_12_ == null || p_184150_12_.apply(entityplayer1)))
             {
                 double d1 = entityplayer1.getDistanceSq(posX, entityplayer1.posY, posZ);
@@ -3447,9 +3807,7 @@
     @Nullable
     public EntityPlayer getPlayerEntityByName(String name)
     {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
-            EntityPlayer entityplayer = this.playerEntities.get(j2);
+        for (EntityPlayer entityplayer: this.playerEntities) {//hose
 
             if (name.equals(entityplayer.getName()))
             {
@@ -3463,9 +3821,7 @@
     @Nullable
     public EntityPlayer getPlayerEntityByUUID(UUID uuid)
     {
-        for (int j2 = 0; j2 < this.playerEntities.size(); ++j2)
-        {
-            EntityPlayer entityplayer = this.playerEntities.get(j2);
+        for (EntityPlayer entityplayer: this.playerEntities) {//hose
 
             if (uuid.equals(entityplayer.getUniqueID()))
             {
@@ -3594,6 +3950,16 @@
     {
     }
 
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus() {
+        if (!this.isRemote) {
+            this.updateAllPlayersSleepingFlag();
+        }
+    }
+    // CraftBukkit end
+
     public float getThunderStrength(float delta)
     {
         return (this.prevThunderingStrength + (this.thunderingStrength - this.prevThunderingStrength) * delta) * this.getRainStrength(delta);
@@ -3882,7 +4248,7 @@
         int j2 = x * 16 + 8 - blockpos1.getX();
         int k2 = z * 16 + 8 - blockpos1.getZ();
         int l2 = 128;
-        return j2 >= -128 && j2 <= 128 && k2 >= -128 && k2 <= 128;
+        return j2 >= -128 && j2 <= 128 && k2 >= -128 && k2 <= 128 && this.keepSpawnInMemory;
     }
 
     /* ======================================== FORGE START =====================================*/
@@ -3950,9 +4316,9 @@
     public int countEntities(net.minecraft.entity.EnumCreatureType type, boolean forSpawnCount)
     {
         int count = 0;
-        for (int x = 0; x < loadedEntityList.size(); x++)
+        for (Entity entity : loadedEntityList)
         {
-            if (((Entity)loadedEntityList.get(x)).isCreatureType(type, forSpawnCount))
+            if (entity.isCreatureType(type, forSpawnCount))
             {
                 count++;
             }
@@ -4018,4 +4384,12 @@
     {
         return null;
     }
+
+    public ImmutableSetMultimap<ChunkPos, ForgeChunkManager.Ticket> getForcedChunks() {
+        return forcedChunks;
+    }
+
+    public void setForcedChunks(ImmutableSetMultimap<ChunkPos, ForgeChunkManager.Ticket> forcedChunks) {
+        this.forcedChunks = forcedChunks;
+    }
 }

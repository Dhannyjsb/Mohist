--- ../src-base/minecraft/net/minecraft/network/NetworkSystem.java
+++ ../src-work/minecraft/net/minecraft/network/NetworkSystem.java
@@ -3,12 +3,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.netty.bootstrap.ServerBootstrap;
-import io.netty.channel.Channel;
-import io.netty.channel.ChannelException;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelInitializer;
-import io.netty.channel.ChannelOption;
-import io.netty.channel.EventLoopGroup;
+import io.netty.channel.*;
 import io.netty.channel.epoll.Epoll;
 import io.netty.channel.epoll.EpollEventLoopGroup;
 import io.netty.channel.epoll.EpollServerSocketChannel;
@@ -21,12 +16,6 @@
 import io.netty.handler.timeout.ReadTimeoutHandler;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.SocketAddress;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
 import net.minecraft.client.network.NetHandlerHandshakeMemory;
 import net.minecraft.crash.CrashReport;
 import net.minecraft.crash.CrashReportCategory;
@@ -42,78 +31,76 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public class NetworkSystem
-{
-    private static final Logger LOGGER = LogManager.getLogger();
-    public static final LazyLoadBase<NioEventLoopGroup> SERVER_NIO_EVENTLOOP = new LazyLoadBase<NioEventLoopGroup>()
-    {
-        protected NioEventLoopGroup load()
-        {
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.SocketAddress;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+
+public class NetworkSystem {
+    public static final LazyLoadBase<NioEventLoopGroup> SERVER_NIO_EVENTLOOP = new LazyLoadBase<NioEventLoopGroup>() {
+        protected NioEventLoopGroup load() {
             return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Server IO #%d").setDaemon(true).setThreadFactory(net.minecraftforge.fml.common.thread.SidedThreadGroups.SERVER).build());
         }
     };
-    public static final LazyLoadBase<EpollEventLoopGroup> SERVER_EPOLL_EVENTLOOP = new LazyLoadBase<EpollEventLoopGroup>()
-    {
-        protected EpollEventLoopGroup load()
-        {
+    public static final LazyLoadBase<EpollEventLoopGroup> SERVER_EPOLL_EVENTLOOP = new LazyLoadBase<EpollEventLoopGroup>() {
+        protected EpollEventLoopGroup load() {
             return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Server IO #%d").setDaemon(true).setThreadFactory(net.minecraftforge.fml.common.thread.SidedThreadGroups.SERVER).build());
         }
     };
-    public static final LazyLoadBase<LocalEventLoopGroup> SERVER_LOCAL_EVENTLOOP = new LazyLoadBase<LocalEventLoopGroup>()
-    {
-        protected LocalEventLoopGroup load()
-        {
+    public static final LazyLoadBase<LocalEventLoopGroup> SERVER_LOCAL_EVENTLOOP = new LazyLoadBase<LocalEventLoopGroup>() {
+        protected LocalEventLoopGroup load() {
             return new LocalEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Server IO #%d").setDaemon(true).setThreadFactory(net.minecraftforge.fml.common.thread.SidedThreadGroups.CLIENT).build());
         }
     };
+    private static final Logger LOGGER = LogManager.getLogger();
     private final MinecraftServer mcServer;
-    public volatile boolean isAlive;
     private final List<ChannelFuture> endpoints = Collections.<ChannelFuture>synchronizedList(Lists.newArrayList());
     private final List<NetworkManager> networkManagers = Collections.<NetworkManager>synchronizedList(Lists.newArrayList());
+    private final Set stack = Collections.newSetFromMap(new ConcurrentHashMap());
+    public volatile boolean isAlive;
+    private boolean processing = false; // Thermos (Robotia) -- syncy time!
 
-    public NetworkSystem(MinecraftServer server)
-    {
+    public NetworkSystem(MinecraftServer server) {
         this.mcServer = server;
         this.isAlive = true;
     }
 
-    public void addLanEndpoint(InetAddress address, int port) throws IOException
-    {
+    public void addLanEndpoint(InetAddress address, int port) throws IOException {
         if (address instanceof java.net.Inet6Address) System.setProperty("java.net.preferIPv4Stack", "false");
-        synchronized (this.endpoints)
-        {
-            Class <? extends ServerSocketChannel > oclass;
-            LazyLoadBase <? extends EventLoopGroup > lazyloadbase;
+        synchronized (this.endpoints) {
+            Class<? extends ServerSocketChannel> oclass;
+            LazyLoadBase<? extends EventLoopGroup> lazyloadbase;
 
-            if (Epoll.isAvailable() && this.mcServer.shouldUseNativeTransport())
-            {
+            if (Epoll.isAvailable() && this.mcServer.shouldUseNativeTransport()) {
                 oclass = EpollServerSocketChannel.class;
                 lazyloadbase = SERVER_EPOLL_EVENTLOOP;
                 LOGGER.info("Using epoll channel type");
-            }
-            else
-            {
+            } else {
                 oclass = NioServerSocketChannel.class;
                 lazyloadbase = SERVER_NIO_EVENTLOOP;
                 LOGGER.info("Using default channel type");
             }
 
-            this.endpoints.add(((ServerBootstrap)((ServerBootstrap)(new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer<Channel>()
-            {
-                protected void initChannel(Channel p_initChannel_1_) throws Exception
-                {
-                    try
-                    {
+            this.endpoints.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer<Channel>() {
+                protected void initChannel(Channel p_initChannel_1_) throws Exception {
+                    try {
                         p_initChannel_1_.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(true));
-                    }
-                    catch (ChannelException var3)
-                    {
+                    } catch (ChannelException var3) {
                         ;
                     }
 
                     p_initChannel_1_.pipeline().addLast("timeout", new ReadTimeoutHandler(net.minecraftforge.fml.common.network.internal.FMLNetworkHandler.READ_TIMEOUT)).addLast("legacy_query", new LegacyPingHandler(NetworkSystem.this)).addLast("splitter", new NettyVarint21FrameDecoder()).addLast("decoder", new NettyPacketDecoder(EnumPacketDirection.SERVERBOUND)).addLast("prepender", new NettyVarint21FrameEncoder()).addLast("encoder", new NettyPacketEncoder(EnumPacketDirection.CLIENTBOUND));
                     NetworkManager networkmanager = new NetworkManager(EnumPacketDirection.SERVERBOUND);
-                    NetworkSystem.this.networkManagers.add(networkmanager);
+                    if (processing) {
+                        stack.add(networkmanager);
+                    } // Thermos (Robotia) -- syncy time
+                    else {
+                        NetworkSystem.this.networkManagers.add(networkmanager);
+                    }
                     p_initChannel_1_.pipeline().addLast("packet_handler", networkmanager);
                     networkmanager.setNetHandler(new NetHandlerHandshakeTCP(NetworkSystem.this.mcServer, networkmanager));
                 }
@@ -122,19 +109,20 @@
     }
 
     @SideOnly(Side.CLIENT)
-    public SocketAddress addLocalEndpoint()
-    {
+    public SocketAddress addLocalEndpoint() {
         ChannelFuture channelfuture;
 
-        synchronized (this.endpoints)
-        {
-            channelfuture = ((ServerBootstrap)((ServerBootstrap)(new ServerBootstrap()).channel(LocalServerChannel.class)).childHandler(new ChannelInitializer<Channel>()
-            {
-                protected void initChannel(Channel p_initChannel_1_) throws Exception
-                {
+        synchronized (this.endpoints) {
+            channelfuture = ((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(LocalServerChannel.class)).childHandler(new ChannelInitializer<Channel>() {
+                protected void initChannel(Channel p_initChannel_1_) throws Exception {
                     NetworkManager networkmanager = new NetworkManager(EnumPacketDirection.SERVERBOUND);
                     networkmanager.setNetHandler(new NetHandlerHandshakeMemory(NetworkSystem.this.mcServer, networkmanager));
-                    NetworkSystem.this.networkManagers.add(networkmanager);
+                    if (processing) {
+                        stack.add(networkmanager);
+                    } // Thermos (Robotia) -- syncy time
+                    else {
+                        NetworkSystem.this.networkManagers.add(networkmanager);
+                    }
                     p_initChannel_1_.pipeline().addLast("packet_handler", networkmanager);
                 }
             }).group(SERVER_NIO_EVENTLOOP.getValue()).localAddress(LocalAddress.ANY)).bind().syncUninterruptibly();
@@ -144,51 +132,42 @@
         return channelfuture.channel().localAddress();
     }
 
-    public void terminateEndpoints()
-    {
+    public void terminateEndpoints() {
         this.isAlive = false;
 
-        for (ChannelFuture channelfuture : this.endpoints)
-        {
-            try
-            {
+        for (ChannelFuture channelfuture : this.endpoints) {
+            try {
                 channelfuture.channel().close().sync();
-            }
-            catch (InterruptedException var4)
-            {
+            } catch (InterruptedException var4) {
                 LOGGER.error("Interrupted whilst closing channel");
             }
         }
     }
 
-    public void networkTick()
-    {
-        synchronized (this.networkManagers)
-        {
+    public void networkTick() {
+        this.processing = true; // Thermos (Robotia)
+        synchronized (this.networkManagers) {
+            // Spigot Start
+            // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
+            if (org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0) {
+                Collections.shuffle(this.networkManagers);
+            }
+            // Spigot End
             Iterator<NetworkManager> iterator = this.networkManagers.iterator();
 
-            while (iterator.hasNext())
-            {
+            while (iterator.hasNext()) {
                 final NetworkManager networkmanager = iterator.next();
 
-                if (!networkmanager.hasNoChannel())
-                {
-                    if (networkmanager.isChannelOpen())
-                    {
-                        try
-                        {
+                if (!networkmanager.hasNoChannel()) {
+                    if (networkmanager.isChannelOpen()) {
+                        try {
                             networkmanager.processReceivedPackets();
-                        }
-                        catch (Exception exception)
-                        {
-                            if (networkmanager.isLocalChannel())
-                            {
+                        } catch (Exception exception) {
+                            if (networkmanager.isLocalChannel()) {
                                 CrashReport crashreport = CrashReport.makeCrashReport(exception, "Ticking memory connection");
                                 CrashReportCategory crashreportcategory = crashreport.makeCategory("Ticking connection");
-                                crashreportcategory.addDetail("Connection", new ICrashReportDetail<String>()
-                                {
-                                    public String call() throws Exception
-                                    {
+                                crashreportcategory.addDetail("Connection", new ICrashReportDetail<String>() {
+                                    public String call() throws Exception {
                                         return networkmanager.toString();
                                     }
                                 });
@@ -197,28 +176,29 @@
 
                             LOGGER.warn("Failed to handle packet for {}", networkmanager.getRemoteAddress(), exception);
                             final TextComponentString textcomponentstring = new TextComponentString("Internal server error");
-                            networkmanager.sendPacket(new SPacketDisconnect(textcomponentstring), new GenericFutureListener < Future <? super Void >> ()
-                            {
-                                public void operationComplete(Future <? super Void > p_operationComplete_1_) throws Exception
-                                {
+                            networkmanager.sendPacket(new SPacketDisconnect(textcomponentstring), new GenericFutureListener<Future<? super Void>>() {
+                                public void operationComplete(Future<? super Void> p_operationComplete_1_) throws Exception {
                                     networkmanager.closeChannel(textcomponentstring);
                                 }
                             });
                             networkmanager.disableAutoRead();
                         }
-                    }
-                    else
-                    {
+                    } else {
+                        // Spigot Start - Fix a race condition where a NetworkManager could be unregistered just before connection.
+                        if (networkmanager.preparing) continue;
+                        // Spigot End
                         iterator.remove();
                         networkmanager.checkDisconnected();
                     }
                 }
             }
         }
+        this.processing = false;
+        this.networkManagers.addAll(stack);
+        stack.clear();
     }
 
-    public MinecraftServer getServer()
-    {
+    public MinecraftServer getServer() {
         return this.mcServer;
     }
 }
